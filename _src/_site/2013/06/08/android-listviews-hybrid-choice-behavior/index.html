<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en" class="no-js" prefix="og: http://ogp.me/ns#"> <!--<![endif]-->
  <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <meta http-equiv="content-language" content="en" />
      <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

      
        <meta name="description" content="A place for discussing anything tech. Old and new. Experiences and Opinions. Questions and rants. Primarily programming-related, but not exclusively.">

      

      <title> Android ListViews: "Hybrid" Choice Behavior | Curious Techizen</title>
      
<link href='http://fonts.googleapis.com/css?family=Roboto:400,700,300,700italic|Source+Code+Pro:400,700' rel='stylesheet' type='text/css'>
<link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
      <link rel="stylesheet" type="text/css" href="/blog/css/main.css" />
      <link href="http://localhost:4000/blog/feed.xml" type="application/rss+xml" rel="alternate" title="RSS2.0">
      <link rel="shortcut icon" href="/blog/favicon.ico">

      
        


      

      <!-- Begin Jekyll SEO tag v2.1.0 -->
<title>Android ListViews: “Hybrid” Choice Behavior - Curious Techizen</title>
<meta property="og:title" content="Android ListViews: “Hybrid” Choice Behavior" />
<meta name="description" content="The goal of this post is to use a ListView in a master/detail configuration where both of the following are possible: Touch a single item to open it.Long-tap multiple items to choose them and perform a common action on them. Note that we wish both these to be possible simultaneously, i.e., even as one item is opened, we wish to allow multiple items (possibly including the item that is opened) to be chosen. This behavior (with some minor variations) is seen in apps like GMail, Google Play Store and the Google I/O 2013 app. The following screenshot shows what we want to achieve. It shows one opened item (Item 5) and two chosen items (Item 3 and Item 8) A note on the terminology Just to avoid confusion, let&#39;s sort of formalize the terminology related to the states an item in the list can be in. An item is opened when the user is viewing the details about that item. In other words, the details of that item are being displayed in the DetailFragment. In dual-pane mode, there needs to be some visual indication in the ListView to let the user know which one of the items is currently opened. When an item is chosen, the Contextual Action Bar appears and the user can perform some action on the item. When multiple items are chosen, only the contextual actions that apply to all of them are to be presented. There needs to be some visual indication in the ListView to let the user know which of the items are currently chosen. Needless to say, this indication needs to differ from the that used to indicate the opened item. Implementation You might notice that one can achieve the opened behavior using ListView&#39;s CHOICE_MODE_SINGLE and the chosen behavior using CHOICE_MODE_MULTIPLE_MODAL. However, it is while trying to combine them that things begin to get challenging, particularly in dual-pane mode. You get either one or the other, but never both. For example, if you use CHOICE_MODE_MULTIPLE_MODAL, then you lose the ability to visually indicate the currently opened item. The solution I ended up with was to not rely on the CHOICE_MODE_MULTIPLE_MODAL, but rather simulate it myself. The high level steps are as follows: Create a custom ListAdapter that keeps track of the currently opened item and the currently chosen itemsIn the getView() (or equivalent) method of your custom ListAdapter, examine the item at the supplied position. If it is the currently opened item, set its visual properties to indicate this. Ditto if it is one of the chosen items.Listen for clicks and long clicks on your ListView and update the adapter defined in step 1 accordingly- i.e., in your OnItemClickListener implementation, set the opened item and in OnItemLongClickListener, update the list of chosen items.OnItemLongClickListener is also where you need to start the action mode (getListView().startActionMode()) if it isn&#39;t started already. HybridChoiceAdapter Here are relevant portions of the code showing how the Adapter should be customized. This code is sparsely commented since I hope that it is self explanatory. Please look at the end of this post for the link to the complete github project. /* Keep track of currently opened item and chosen items */ private Set&lt;Integer&gt; chosenItems = new HashSet&lt;Integer&gt;(); private int openedItem = -1; //...snip... public void setItemChosen(int position, boolean chosen) { if (!chosen &amp;&amp; isItemChosen(position)) { chosenItems.remove(position); } else if (chosen &amp;&amp; !isItemChosen(position)) { chosenItems.add(position); } } public boolean isItemChosen(int position) { return chosenItems.contains(position); } public Set&lt;Integer&gt; getChosenItems() { return chosenItems; } public void setOpenedItem(int position) { this.openedItem = position; } public int getOpenedItem() { return this.openedItem; } public boolean isItemOpened(int position) { return this.openedItem == position; } public void clearChoices() { chosenItems.clear(); } public void toggleItem(int position) { if (isItemChosen(position)) { chosenItems.remove(position); } else { chosenItems.add(position); } } public int getChosenItemsCount(){ return this.chosenItems.size(); } The getView() method At this point, we have set up the Adapter to keep track of the currently opened item and the chosen items too. We have also exposed methods to manipulate these values. Now, lets look at the code that updates the UI. It is rather simple - all we need to do is, set the background of the row view depending on the opened and chosen states of the current item. Note that an item can be both opened and chosen. @Override public final View getView(final int position, View convertView, ViewGroup parent) { View v = convertView; /*Normal procedure to inflate the row layout and set its properties goes here*/ v.setBackgroundResource(0); if (isItemOpened(position)) { setViewAsOpened(v); //This method sets the appropriate background resource or drawable } if (isItemChosen(position)) { setViewAsChosen(v);//This method sets the appropriate background resource or drawable } return v; } Listening for clicks on the ListView In your Activity or Fragment, we listen for both clicks and long clicks and update the adapter accordingly. Again, only the relevant portions of the code are presented here - the full project is shared on github (linked at the end of this post). Here we use a ListAdapter that also implements OnItemLongClickListener. @Override public void onListItemClick(ListView listView, View view, int position, long id) { super.onListItemClick(listView, view, position, id); //When an item is clicked, set it as the opened item mAdapter.setOpenedItem(position); //At this point, clear all choices mAdapter.clearChoices(); if(mActionMode != null){ mActionMode.finish(); } mAdapter.notifyDataSetChanged(); // code to show the details fragment goes here } @Override public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { //When an item is long clicked, toggle its chosen state //Also update the CAB title to reflect the change in number of chosen items mAdapter.toggleItem(position); updateActionMode(); return true; } private void updateActionMode(){ if(mActionMode == null){ mActionMode = getListView().startActionMode(actionModeCallback); } mActionMode.setTitle(String.format(&quot;%d chosen&quot;, mAdapter.getChosenItems().size())); mAdapter.notifyDataSetChanged(); } The previous code snippet also includes step 4 from our high level overview. If the CAB is not already shown, we show it when an item is long clicked. That mostly covers what we need to do to achieve our goal. There are a few other things that need to be taken care of (for example, clearing the choices whenever the CAB is dismissed - as a result of a contextual action being performed, or otherwise). You can examine the entire code in detail at the github repository. Variations There are subtle variations of what action the user has to take to choose an item. For example, The old GMail app (v4.3) displayed check boxes for each row. So you could choose an item either by long-pressing it, or by tapping the check box.In the new GMail app and the Google I/O 2013 app, when no item is chosen, you long-press an item to choose it. After that, even single clicking on other items chooses them. This is different from our implementation where a single-tap always opens an item. You will need to modify the code for the click listeners if you want to go with one of these variations. The ListAdapter code itself should remain the same. Turning this into a library? Well, I gave this a thought too. Exposing the custom Adapter as a library is the easy part. What I couldn&#39;t decide upon is how to include the ListView listeners in a library. Developers might wish to extend ListActivity or ListFragment or simply include a ListView in their layouts. Catering to so many requirements is a tough ask (unless I want to provide custom base versions of all these classes ... plus their Sherlock counterparts!) If anyone has any ideas on how this could be library-ized, please do drop a comment. GitHub repositroy The complete source code for this article is available as a sample project on GitHub here." />
<meta property="og:description" content="The goal of this post is to use a ListView in a master/detail configuration where both of the following are possible: Touch a single item to open it.Long-tap multiple items to choose them and perform a common action on them. Note that we wish both these to be possible simultaneously, i.e., even as one item is opened, we wish to allow multiple items (possibly including the item that is opened) to be chosen. This behavior (with some minor variations) is seen in apps like GMail, Google Play Store and the Google I/O 2013 app. The following screenshot shows what we want to achieve. It shows one opened item (Item 5) and two chosen items (Item 3 and Item 8) A note on the terminology Just to avoid confusion, let&#39;s sort of formalize the terminology related to the states an item in the list can be in. An item is opened when the user is viewing the details about that item. In other words, the details of that item are being displayed in the DetailFragment. In dual-pane mode, there needs to be some visual indication in the ListView to let the user know which one of the items is currently opened. When an item is chosen, the Contextual Action Bar appears and the user can perform some action on the item. When multiple items are chosen, only the contextual actions that apply to all of them are to be presented. There needs to be some visual indication in the ListView to let the user know which of the items are currently chosen. Needless to say, this indication needs to differ from the that used to indicate the opened item. Implementation You might notice that one can achieve the opened behavior using ListView&#39;s CHOICE_MODE_SINGLE and the chosen behavior using CHOICE_MODE_MULTIPLE_MODAL. However, it is while trying to combine them that things begin to get challenging, particularly in dual-pane mode. You get either one or the other, but never both. For example, if you use CHOICE_MODE_MULTIPLE_MODAL, then you lose the ability to visually indicate the currently opened item. The solution I ended up with was to not rely on the CHOICE_MODE_MULTIPLE_MODAL, but rather simulate it myself. The high level steps are as follows: Create a custom ListAdapter that keeps track of the currently opened item and the currently chosen itemsIn the getView() (or equivalent) method of your custom ListAdapter, examine the item at the supplied position. If it is the currently opened item, set its visual properties to indicate this. Ditto if it is one of the chosen items.Listen for clicks and long clicks on your ListView and update the adapter defined in step 1 accordingly- i.e., in your OnItemClickListener implementation, set the opened item and in OnItemLongClickListener, update the list of chosen items.OnItemLongClickListener is also where you need to start the action mode (getListView().startActionMode()) if it isn&#39;t started already. HybridChoiceAdapter Here are relevant portions of the code showing how the Adapter should be customized. This code is sparsely commented since I hope that it is self explanatory. Please look at the end of this post for the link to the complete github project. /* Keep track of currently opened item and chosen items */ private Set&lt;Integer&gt; chosenItems = new HashSet&lt;Integer&gt;(); private int openedItem = -1; //...snip... public void setItemChosen(int position, boolean chosen) { if (!chosen &amp;&amp; isItemChosen(position)) { chosenItems.remove(position); } else if (chosen &amp;&amp; !isItemChosen(position)) { chosenItems.add(position); } } public boolean isItemChosen(int position) { return chosenItems.contains(position); } public Set&lt;Integer&gt; getChosenItems() { return chosenItems; } public void setOpenedItem(int position) { this.openedItem = position; } public int getOpenedItem() { return this.openedItem; } public boolean isItemOpened(int position) { return this.openedItem == position; } public void clearChoices() { chosenItems.clear(); } public void toggleItem(int position) { if (isItemChosen(position)) { chosenItems.remove(position); } else { chosenItems.add(position); } } public int getChosenItemsCount(){ return this.chosenItems.size(); } The getView() method At this point, we have set up the Adapter to keep track of the currently opened item and the chosen items too. We have also exposed methods to manipulate these values. Now, lets look at the code that updates the UI. It is rather simple - all we need to do is, set the background of the row view depending on the opened and chosen states of the current item. Note that an item can be both opened and chosen. @Override public final View getView(final int position, View convertView, ViewGroup parent) { View v = convertView; /*Normal procedure to inflate the row layout and set its properties goes here*/ v.setBackgroundResource(0); if (isItemOpened(position)) { setViewAsOpened(v); //This method sets the appropriate background resource or drawable } if (isItemChosen(position)) { setViewAsChosen(v);//This method sets the appropriate background resource or drawable } return v; } Listening for clicks on the ListView In your Activity or Fragment, we listen for both clicks and long clicks and update the adapter accordingly. Again, only the relevant portions of the code are presented here - the full project is shared on github (linked at the end of this post). Here we use a ListAdapter that also implements OnItemLongClickListener. @Override public void onListItemClick(ListView listView, View view, int position, long id) { super.onListItemClick(listView, view, position, id); //When an item is clicked, set it as the opened item mAdapter.setOpenedItem(position); //At this point, clear all choices mAdapter.clearChoices(); if(mActionMode != null){ mActionMode.finish(); } mAdapter.notifyDataSetChanged(); // code to show the details fragment goes here } @Override public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { //When an item is long clicked, toggle its chosen state //Also update the CAB title to reflect the change in number of chosen items mAdapter.toggleItem(position); updateActionMode(); return true; } private void updateActionMode(){ if(mActionMode == null){ mActionMode = getListView().startActionMode(actionModeCallback); } mActionMode.setTitle(String.format(&quot;%d chosen&quot;, mAdapter.getChosenItems().size())); mAdapter.notifyDataSetChanged(); } The previous code snippet also includes step 4 from our high level overview. If the CAB is not already shown, we show it when an item is long clicked. That mostly covers what we need to do to achieve our goal. There are a few other things that need to be taken care of (for example, clearing the choices whenever the CAB is dismissed - as a result of a contextual action being performed, or otherwise). You can examine the entire code in detail at the github repository. Variations There are subtle variations of what action the user has to take to choose an item. For example, The old GMail app (v4.3) displayed check boxes for each row. So you could choose an item either by long-pressing it, or by tapping the check box.In the new GMail app and the Google I/O 2013 app, when no item is chosen, you long-press an item to choose it. After that, even single clicking on other items chooses them. This is different from our implementation where a single-tap always opens an item. You will need to modify the code for the click listeners if you want to go with one of these variations. The ListAdapter code itself should remain the same. Turning this into a library? Well, I gave this a thought too. Exposing the custom Adapter as a library is the easy part. What I couldn&#39;t decide upon is how to include the ListView listeners in a library. Developers might wish to extend ListActivity or ListFragment or simply include a ListView in their layouts. Catering to so many requirements is a tough ask (unless I want to provide custom base versions of all these classes ... plus their Sherlock counterparts!) If anyone has any ideas on how this could be library-ized, please do drop a comment. GitHub repositroy The complete source code for this article is available as a sample project on GitHub here." />
<link rel="canonical" href="http://localhost:4000/blog/2013/06/08/android-listviews-hybrid-choice-behavior/" />
<meta property="og:url" content="http://localhost:4000/blog/2013/06/08/android-listviews-hybrid-choice-behavior/" />
<meta property="og:site_name" content="Curious Techizen" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-06-08T20:03:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@ki_run" />
<meta name="twitter:creator" content="@Kiran Rao" />
<script type="application/ld+json">
{"@context": "http://schema.org",
"@type": "BlogPosting",
"headline": "Android ListViews: “Hybrid” Choice Behavior",
"datePublished": "2013-06-08T20:03:00+02:00",
"description": "The goal of this post is to use a ListView in a master/detail configuration where both of the following are possible: Touch a single item to open it.Long-tap multiple items to choose them and perform a common action on them. Note that we wish both these to be possible simultaneously, i.e., even as one item is opened, we wish to allow multiple items (possibly including the item that is opened) to be chosen. This behavior (with some minor variations) is seen in apps like GMail, Google Play Store and the Google I/O 2013 app. The following screenshot shows what we want to achieve. It shows one opened item (Item 5) and two chosen items (Item 3 and Item 8) A note on the terminology Just to avoid confusion, let&#39;s sort of formalize the terminology related to the states an item in the list can be in. An item is opened when the user is viewing the details about that item. In other words, the details of that item are being displayed in the DetailFragment. In dual-pane mode, there needs to be some visual indication in the ListView to let the user know which one of the items is currently opened. When an item is chosen, the Contextual Action Bar appears and the user can perform some action on the item. When multiple items are chosen, only the contextual actions that apply to all of them are to be presented. There needs to be some visual indication in the ListView to let the user know which of the items are currently chosen. Needless to say, this indication needs to differ from the that used to indicate the opened item. Implementation You might notice that one can achieve the opened behavior using ListView&#39;s CHOICE_MODE_SINGLE and the chosen behavior using CHOICE_MODE_MULTIPLE_MODAL. However, it is while trying to combine them that things begin to get challenging, particularly in dual-pane mode. You get either one or the other, but never both. For example, if you use CHOICE_MODE_MULTIPLE_MODAL, then you lose the ability to visually indicate the currently opened item. The solution I ended up with was to not rely on the CHOICE_MODE_MULTIPLE_MODAL, but rather simulate it myself. The high level steps are as follows: Create a custom ListAdapter that keeps track of the currently opened item and the currently chosen itemsIn the getView() (or equivalent) method of your custom ListAdapter, examine the item at the supplied position. If it is the currently opened item, set its visual properties to indicate this. Ditto if it is one of the chosen items.Listen for clicks and long clicks on your ListView and update the adapter defined in step 1 accordingly- i.e., in your OnItemClickListener implementation, set the opened item and in OnItemLongClickListener, update the list of chosen items.OnItemLongClickListener is also where you need to start the action mode (getListView().startActionMode()) if it isn&#39;t started already. HybridChoiceAdapter Here are relevant portions of the code showing how the Adapter should be customized. This code is sparsely commented since I hope that it is self explanatory. Please look at the end of this post for the link to the complete github project. /* Keep track of currently opened item and chosen items */ private Set&lt;Integer&gt; chosenItems = new HashSet&lt;Integer&gt;(); private int openedItem = -1; //...snip... public void setItemChosen(int position, boolean chosen) { if (!chosen &amp;&amp; isItemChosen(position)) { chosenItems.remove(position); } else if (chosen &amp;&amp; !isItemChosen(position)) { chosenItems.add(position); } } public boolean isItemChosen(int position) { return chosenItems.contains(position); } public Set&lt;Integer&gt; getChosenItems() { return chosenItems; } public void setOpenedItem(int position) { this.openedItem = position; } public int getOpenedItem() { return this.openedItem; } public boolean isItemOpened(int position) { return this.openedItem == position; } public void clearChoices() { chosenItems.clear(); } public void toggleItem(int position) { if (isItemChosen(position)) { chosenItems.remove(position); } else { chosenItems.add(position); } } public int getChosenItemsCount(){ return this.chosenItems.size(); } The getView() method At this point, we have set up the Adapter to keep track of the currently opened item and the chosen items too. We have also exposed methods to manipulate these values. Now, lets look at the code that updates the UI. It is rather simple - all we need to do is, set the background of the row view depending on the opened and chosen states of the current item. Note that an item can be both opened and chosen. @Override public final View getView(final int position, View convertView, ViewGroup parent) { View v = convertView; /*Normal procedure to inflate the row layout and set its properties goes here*/ v.setBackgroundResource(0); if (isItemOpened(position)) { setViewAsOpened(v); //This method sets the appropriate background resource or drawable } if (isItemChosen(position)) { setViewAsChosen(v);//This method sets the appropriate background resource or drawable } return v; } Listening for clicks on the ListView In your Activity or Fragment, we listen for both clicks and long clicks and update the adapter accordingly. Again, only the relevant portions of the code are presented here - the full project is shared on github (linked at the end of this post). Here we use a ListAdapter that also implements OnItemLongClickListener. @Override public void onListItemClick(ListView listView, View view, int position, long id) { super.onListItemClick(listView, view, position, id); //When an item is clicked, set it as the opened item mAdapter.setOpenedItem(position); //At this point, clear all choices mAdapter.clearChoices(); if(mActionMode != null){ mActionMode.finish(); } mAdapter.notifyDataSetChanged(); // code to show the details fragment goes here } @Override public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { //When an item is long clicked, toggle its chosen state //Also update the CAB title to reflect the change in number of chosen items mAdapter.toggleItem(position); updateActionMode(); return true; } private void updateActionMode(){ if(mActionMode == null){ mActionMode = getListView().startActionMode(actionModeCallback); } mActionMode.setTitle(String.format(&quot;%d chosen&quot;, mAdapter.getChosenItems().size())); mAdapter.notifyDataSetChanged(); } The previous code snippet also includes step 4 from our high level overview. If the CAB is not already shown, we show it when an item is long clicked. That mostly covers what we need to do to achieve our goal. There are a few other things that need to be taken care of (for example, clearing the choices whenever the CAB is dismissed - as a result of a contextual action being performed, or otherwise). You can examine the entire code in detail at the github repository. Variations There are subtle variations of what action the user has to take to choose an item. For example, The old GMail app (v4.3) displayed check boxes for each row. So you could choose an item either by long-pressing it, or by tapping the check box.In the new GMail app and the Google I/O 2013 app, when no item is chosen, you long-press an item to choose it. After that, even single clicking on other items chooses them. This is different from our implementation where a single-tap always opens an item. You will need to modify the code for the click listeners if you want to go with one of these variations. The ListAdapter code itself should remain the same. Turning this into a library? Well, I gave this a thought too. Exposing the custom Adapter as a library is the easy part. What I couldn&#39;t decide upon is how to include the ListView listeners in a library. Developers might wish to extend ListActivity or ListFragment or simply include a ListView in their layouts. Catering to so many requirements is a tough ask (unless I want to provide custom base versions of all these classes ... plus their Sherlock counterparts!) If anyone has any ideas on how this could be library-ized, please do drop a comment. GitHub repositroy The complete source code for this article is available as a sample project on GitHub here.",
"url": "http://localhost:4000/blog/2013/06/08/android-listviews-hybrid-choice-behavior/"}</script>
<!-- End Jekyll SEO tag -->

      
      <script>if(!sessionStorage.getItem("_swa")&&document.referrer.indexOf(location.protocol+"//"+location.host)!== 0){fetch("https://counter.dev/track?"+new URLSearchParams({referrer:document.referrer,screen:screen.width+"x"+screen.height,user:"curioustechizen",utcoffset:"1"}))};sessionStorage.setItem("_swa","1");</script>

  </head>

  <body>
    <!--[if lt IE 7]>
        <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
    <![endif]-->

    <div class="off-canvas">
      <figure class="avatar">
        <img src="/blog/assets/img/avatar.jpg" alt="Picture" title="That's me, Kiran Rao.">
      </figure>
      <div class="bio">
          <h1>Hi, I'm Kiran Rao.</h1>
          <p>Android Developer. Tech enthusiast. Serial dabbler.</p>
      </div>
      <nav>
        <h6>Follow me on</h6>
        <ul>
          
          <li><a target="_blank" href="http://twitter.com/ki_run">Twitter</a></li>
          
          
          <li><a target="_blank" href="https://github.com/curioustechizen">Github</a></li>
          
          
          
          
          <li><a target="_blank" href="https://plus.google.com/116652261752707476836">Google+</a></li>
          
        </ul>
      </nav>
      <nav>
        <h6>Link</h6>
        <ul>
          <li><a href="/blog/">Home</a></li>
          <li><a href="/blog/tags/">Tags</a></li>
        </ul>
      </nav>
    </div>

    <div class="site-wrapper">

      <header>
        <div class="h-wrap">
          <h1 class="title"><a href="/blog/" title="Back to Homepage">Curious Techizen</a></h1>
          <a class="menu-icon" title="Open Bio"><span class="lines"></span></a>
        </div>
      </header>

      <main>
        <section class="single-wrap">
  <article class="single-content" itemscope itemtype="http://schema.org/BlogPosting">
    <div class="feat">
      <h5 class="page-date">
        <time datetime="2013-06-08T20:03:00+02:00" itemprop="datePublished">
          08 June 2013
        </time>
      </h5>
    </div>
    <h1 class="page-title" itemprop="name headline">Android ListViews: "Hybrid" Choice Behavior</h1>
    <div itemprop="articleBody">
      <p>The goal of this post is to use a <code>ListView</code> in a master/detail configuration where <em>both</em> of the following are possible:</p> <ol><li>Touch a single item to <strong>open</strong> it.</li><li>Long-tap multiple items to <strong>choose</strong> them and perform a common action on them.</li></ol> <p>Note that we wish both these to be possible simultaneously, i.e., even as one item is opened, we wish to allow multiple items (possibly including the item that is opened) to be chosen.</p> <p>This behavior (with some minor variations) is seen in apps like GMail, Google Play Store and the Google I/O 2013 app.</p> <p>The following screenshot shows what we want to achieve. It shows one opened item (Item 5) and two chosen items (Item 3 and Item 8)</p> <p><img src="https://lh5.googleusercontent.com/-HVUbT2xSCHE/UbNPf0kqtFI/AAAAAAAAAHk/cAFBmm4HglY/s512/target_ui.png" alt="This is what we want to achieve" title="target_ui.png"></p> <h3 id="a-note-on-the-terminology">A note on the terminology</h3> <p>Just to avoid confusion, let's sort of formalize the terminology related to the states an item in the list can be in.</p> <blockquote>  <p>An item is <strong>opened</strong> when the user is viewing the details about that item. In other words, the details of that item are being displayed in the <code>DetailFragment</code>. In dual-pane mode, there needs to be some visual indication in the <code>ListView</code> to let the user know which one of the items is currently opened.</p>     <p>When an item is <strong>chosen</strong>, the Contextual Action Bar appears and the user can perform some action on the item. When multiple items are chosen, only the contextual actions that apply to all of them are to be presented. There needs to be some visual indication in the <code>ListView</code> to let the user know which of the items are currently chosen. Needless to say, this indication needs to differ from the that used to indicate the opened item.</p></blockquote> <h3 id="implementation">Implementation</h3> <p>You might notice that one can achieve the opened behavior using <code>ListView</code>'s <code>CHOICE_MODE_SINGLE</code> and the chosen behavior using <code>CHOICE_MODE_MULTIPLE_MODAL</code>. However, it is while trying to combine them that things begin to get challenging, particularly in dual-pane mode. You get either one or the other, but never both. For example, if you use <code>CHOICE_MODE_MULTIPLE_MODAL</code>, then you lose the ability to visually indicate the currently opened item.</p> <p>The solution I ended up with was to not rely on the <code>CHOICE_MODE_MULTIPLE_MODAL</code>, but rather simulate it myself. The high level steps are as follows:</p> <ol><li>Create a custom <code>ListAdapter</code> that keeps track of the currently opened item and the currently chosen items</li><li>In the <code>getView()</code> (or equivalent) method of your custom <code>ListAdapter</code>, examine the item at the supplied <code>position</code>. If it is the currently opened item, set its visual properties to indicate this. Ditto if it is one of the chosen items.</li><li>Listen for clicks and long clicks on your <code>ListView</code> and update the adapter defined in step 1 accordingly- i.e., in your <code>OnItemClickListener</code> implementation, set the opened item and in <code>OnItemLongClickListener</code>, update the list of chosen items.</li><li><code>OnItemLongClickListener</code> is also where you need to start the action mode (<code>getListView().startActionMode()</code>) if it isn't started already.</li></ol> <h3 id="hybridchoiceadapter">HybridChoiceAdapter</h3> <p>Here are relevant portions of the code showing how the Adapter should be customized. This code is sparsely commented since I hope that it is self explanatory. Please look at the end of this post for the link to the complete github project.</p> <pre class="prettyprint prettyprinted" style=""><code><span class="pln">    </span><span class="com">/* Keep track of currently opened item and chosen items */</span><span class="pln"><br />    </span><span class="kwd">private</span><span class="pln"> </span><span class="typ">Set</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;</span><span class="pln"> chosenItems </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">HashSet</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;();</span><span class="pln"><br />    </span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> openedItem </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">;</span><span class="pln"><br /><br />    </span><span class="com">//...snip...</span><span class="pln"><br /><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> setItemChosen</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> position</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> chosen</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">chosen </span><span class="pun">&amp;&amp;</span><span class="pln"> isItemChosen</span><span class="pun">(</span><span class="pln">position</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />            chosenItems</span><span class="pun">.</span><span class="pln">remove</span><span class="pun">(</span><span class="pln">position</span><span class="pun">);</span><span class="pln"><br />        </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">chosen </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">!</span><span class="pln">isItemChosen</span><span class="pun">(</span><span class="pln">position</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />            chosenItems</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="pln">position</span><span class="pun">);</span><span class="pln"><br />        </span><span class="pun">}</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> isItemChosen</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> position</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="kwd">return</span><span class="pln"> chosenItems</span><span class="pun">.</span><span class="pln">contains</span><span class="pun">(</span><span class="pln">position</span><span class="pun">);</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">Set</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;</span><span class="pln"> getChosenItems</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="kwd">return</span><span class="pln"> chosenItems</span><span class="pun">;</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> setOpenedItem</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> position</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">openedItem </span><span class="pun">=</span><span class="pln"> position</span><span class="pun">;</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> getOpenedItem</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">openedItem</span><span class="pun">;</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> isItemOpened</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> position</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">openedItem </span><span class="pun">==</span><span class="pln"> position</span><span class="pun">;</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> clearChoices</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        chosenItems</span><span class="pun">.</span><span class="pln">clear</span><span class="pun">();</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> toggleItem</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> position</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">isItemChosen</span><span class="pun">(</span><span class="pln">position</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />            chosenItems</span><span class="pun">.</span><span class="pln">remove</span><span class="pun">(</span><span class="pln">position</span><span class="pun">);</span><span class="pln"><br />        </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />            chosenItems</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="pln">position</span><span class="pun">);</span><span class="pln"><br />        </span><span class="pun">}</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> getChosenItemsCount</span><span class="pun">(){</span><span class="pln"><br />        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">chosenItems</span><span class="pun">.</span><span class="pln">size</span><span class="pun">();</span><span class="pln"><br />    </span><span class="pun">}</span></code></pre> <h3 id="the-getview-method">The <code>getView()</code> method</h3> <p>At this point, we have set up the <code>Adapter</code> to keep track of the currently opened item and the chosen items too. We have also exposed methods to manipulate these values. Now, lets look at the code that updates the UI. It is rather simple - all we need to do is, set the background of the row view depending on the opened and chosen states of the current item. Note that an item can be both opened and chosen.</p> <pre class="prettyprint prettyprinted" style=""><code><span class="pln">    </span><span class="lit">@Override</span><span class="pln"><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">View</span><span class="pln"> getView</span><span class="pun">(</span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> position</span><span class="pun">,</span><span class="pln"> </span><span class="typ">View</span><span class="pln"> convertView</span><span class="pun">,</span><span class="pln"><br />            </span><span class="typ">ViewGroup</span><span class="pln"> parent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="typ">View</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> convertView</span><span class="pun">;</span><span class="pln"><br />        </span><span class="com">/*Normal procedure to inflate the row layout and set its properties goes here*/</span><span class="pln"><br /><br />        v</span><span class="pun">.</span><span class="pln">setBackgroundResource</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln"><br />        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">isItemOpened</span><span class="pun">(</span><span class="pln">position</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />            setViewAsOpened</span><span class="pun">(</span><span class="pln">v</span><span class="pun">);</span><span class="pln"> </span><span class="com">//This method sets the appropriate background resource or drawable</span><span class="pln"><br />        </span><span class="pun">}</span><span class="pln"><br /><br />        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">isItemChosen</span><span class="pun">(</span><span class="pln">position</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />            setViewAsChosen</span><span class="pun">(</span><span class="pln">v</span><span class="pun">);</span><span class="com">//This method sets the appropriate background resource or drawable</span><span class="pln"><br />        </span><span class="pun">}</span><span class="pln"><br /><br />        </span><span class="kwd">return</span><span class="pln"> v</span><span class="pun">;</span><span class="pln"><br />    </span><span class="pun">}</span></code></pre> <h3 id="listening-for-clicks-on-the-listview">Listening for clicks on the <code>ListView</code></h3> <p>In your <code>Activity</code> or <code>Fragment</code>, we listen for both clicks and long clicks and update the adapter accordingly. Again, only the relevant portions of the code are presented here - the full project is shared on github (linked at the end of this post). Here we use a <code>ListAdapter</code> that also implements <code>OnItemLongClickListener</code>.</p> <pre class="prettyprint prettyprinted" style=""><code><span class="pln">    </span><span class="lit">@Override</span><span class="pln"><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> onListItemClick</span><span class="pun">(</span><span class="typ">ListView</span><span class="pln"> listView</span><span class="pun">,</span><span class="pln"> </span><span class="typ">View</span><span class="pln"> view</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> position</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> id</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">onListItemClick</span><span class="pun">(</span><span class="pln">listView</span><span class="pun">,</span><span class="pln"> view</span><span class="pun">,</span><span class="pln"> position</span><span class="pun">,</span><span class="pln"> id</span><span class="pun">);</span><span class="pln"><br /><br />        </span><span class="com">//When an item is clicked, set it as the opened item</span><span class="pln"><br />        mAdapter</span><span class="pun">.</span><span class="pln">setOpenedItem</span><span class="pun">(</span><span class="pln">position</span><span class="pun">);</span><span class="pln"><br /><br />        </span><span class="com">//At this point, clear all choices</span><span class="pln"><br />        mAdapter</span><span class="pun">.</span><span class="pln">clearChoices</span><span class="pun">();</span><span class="pln"><br />        </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">mActionMode </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">){</span><span class="pln"><br />            mActionMode</span><span class="pun">.</span><span class="pln">finish</span><span class="pun">();</span><span class="pln"><br />        </span><span class="pun">}</span><span class="pln"><br />        mAdapter</span><span class="pun">.</span><span class="pln">notifyDataSetChanged</span><span class="pun">();</span><span class="pln"><br /><br />         </span><span class="com">// code to show the details fragment goes here</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /><br />    </span><span class="lit">@Override</span><span class="pln"><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> onItemLongClick</span><span class="pun">(</span><span class="typ">AdapterView</span><span class="pun">&lt;?&gt;</span><span class="pln"> parent</span><span class="pun">,</span><span class="pln"> </span><span class="typ">View</span><span class="pln"> view</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> position</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> id</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br /><br />        </span><span class="com">//When an item is long clicked, toggle its chosen state</span><span class="pln"><br />        </span><span class="com">//Also update the CAB title to reflect the change in number of chosen items</span><span class="pln"><br />        mAdapter</span><span class="pun">.</span><span class="pln">toggleItem</span><span class="pun">(</span><span class="pln">position</span><span class="pun">);</span><span class="pln"><br />        updateActionMode</span><span class="pun">();</span><span class="pln"><br />        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /><br />    </span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> updateActionMode</span><span class="pun">(){</span><span class="pln"><br />        </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">mActionMode </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">){</span><span class="pln"><br />            mActionMode </span><span class="pun">=</span><span class="pln"> getListView</span><span class="pun">().</span><span class="pln">startActionMode</span><span class="pun">(</span><span class="pln">actionModeCallback</span><span class="pun">);</span><span class="pln"><br />        </span><span class="pun">}</span><span class="pln"><br /><br />        mActionMode</span><span class="pun">.</span><span class="pln">setTitle</span><span class="pun">(</span><span class="typ">String</span><span class="pun">.</span><span class="pln">format</span><span class="pun">(</span><span class="str">"%d chosen"</span><span class="pun">,</span><span class="pln"> mAdapter</span><span class="pun">.</span><span class="pln">getChosenItems</span><span class="pun">().</span><span class="pln">size</span><span class="pun">()));</span><span class="pln"><br />        mAdapter</span><span class="pun">.</span><span class="pln">notifyDataSetChanged</span><span class="pun">();</span><span class="pln"><br />    </span><span class="pun">}</span></code></pre> <p>The previous code snippet also includes step 4 from our high level overview. If the CAB is not already shown, we show it when an item is long clicked.</p> <p>That mostly covers what we need to do to achieve our goal. There are a few other things that need to be taken care of (for example, clearing the choices whenever the CAB is dismissed - as a result of a contextual action being performed, or otherwise). You can examine the entire code in detail at the github repository.</p> <h3 id="variations">Variations</h3> <p>There are subtle variations of what action the user has to take to choose an item. For example,</p> <ul><li>The old GMail app (v4.3) displayed check boxes for each row. So you could choose an item either by long-pressing it, or by tapping the check box.</li><li>In the new GMail app and the Google I/O 2013 app, when no item is chosen, you long-press an item to choose it. After that, <strong>even single clicking on other items chooses them</strong>. This is different from our implementation where a single-tap always opens an item.</li></ul> <p>You will need to modify the code for the click listeners if you want to go with one of these variations. The <code>ListAdapter</code> code itself should remain the same.</p> <h3 id="turning-this-into-a-library">Turning this into a library?</h3> <p>Well, I gave this a thought too. Exposing the custom <code>Adapter</code> as a library is the easy part. What I couldn't decide upon is how to include the <code>ListView</code> listeners  in a library. Developers might wish to extend <code>ListActivity</code> or <code>ListFragment</code> or simply include a <code>ListView</code> in their layouts. Catering to so many requirements is a tough ask (unless I want to provide custom base versions of all these classes ... plus their <code>Sherlock</code> counterparts!)</p> <p>If anyone has any ideas on how this could be library-ized, please do drop a comment.</p> <h3 id="github-repositroy">GitHub repositroy</h3> <p>The complete source code for this article is available as a sample project on GitHub <a href="https://github.com/curioustechizen/android-hybridchoice">here</a>.</p>
    </div>
    
    <div class="page-tags">
      <ul>
        
        <li>
          
          <a href="javascript:void(0);" class="disabled">choicemode</a>
          
        </li>
        
        <li>
          
          <a href="javascript:void(0);" class="disabled">listview</a>
          
        </li>
        
        <li>
          
          <a href="/blog/tags/android">Android</a>
          
        </li>
        
      </ul>
    </div>
    
    <h6 class="back-to-top"><a href="#top">Back to Top</a></h6>
    
      <a rel="next" href="/blog/2014/01/25/nested-fragments-and-back-stack/" id="next">
        <span class="nav-title nav-title-next">newer</span> &rarr;
      </a>
    
    
      <a rel="prev" href="/blog/2013/03/09/shift-to-octopress-postponed/" id="prev">
        &larr; <span class="nav-title nav-title-prev">older</span>
      </a>
    
  </article>
  
</section>

      </main>

      <footer>
        <small>Powered by Jekyll - Theme: <a href="https://github.com/ogaclejapan/materi-for-jekyll">materi</a> - &copy; ogaclejapan</small>
      </footer>

    </div>
    

    <script src="/blog/js/main.js"></script>
    
    
  </body>
</html>
