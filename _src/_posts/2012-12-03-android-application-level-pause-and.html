---
layout: post
title: 'Android: "Application level" Pause and Resume'
date: '2012-12-03T23:13:00.000+05:30'
author: Kiran Rao
tags:
- Application
- onResume
- development
- android
- onPause
modified_time: '2012-12-09T22:16:33.283+05:30'
blogger_id: tag:blogger.com,1999:blog-1898571694993659507.post-4939962054574237253
blogger_orig_url: http://curioustechizen.blogspot.com/2012/12/android-application-level-pause-and.html
---

<h3>Update</h3><p>I have created an open source library using the concepts presented in this post. You can directly use the library to create your apps. Get it at <a href="https://github.com/curioustechizen/android-app-pause">android-app-pause</a> on github</p><h3>Introduction</h3><p>I have often come across questions on StackOverflow and the android-developers google group about an <code>Application</code>-level <code>onPause()</code> and <code>onResume()</code>. In this post, I present one of the ways of achieving such functionality. But before that, what exactly do I mean by an app-level <code>onPause()</code>?</p><p>After all, an Android app consists of multiple components, several of which might be in the background. There could be <code>Service</code>s, <code>Thread</code>s, <code>BroadcastReceiver</code>s, scheduled <code>Alarm</code>s. How do these figure in a "paused" app? Well, here's my definition of an app being paused for the purposes of this post:</p><blockquote><p>An app is considered to be paused when the app is no longer visible to the user. By definition, this means that when an app is paused, <em>none of the Activities that belong to the app</em> are visible to the user.</p></blockquote><p>In my opinion, this is a fair definition since this would typically be the point when the app wishes to "pause" any background work it does. For example, an app might wish to cancel all scheduled alarms, or stop making HTTP calls when it knows that the user is no longer interacting with the app.</p><blockquote><p>Similarly, an app is considered to be resumed when at least one <code>Activity</code> from the app is visible to the user.</p></blockquote><p>This is the point at which the app can re-establish HTTP communication, re-schedule alarms and the like.</p><h3>TL;DR</h3><p>I got this idea from <a href="http://stackoverflow.com/a/7924855/570930">this answer</a> that I gave on stackoverflow. The basis of this approach is that when an Activity starts another, both of them <a href="http://developer.android.com/guide/components/activities.html#CoordinatingActivities">undergo lifecycle changes</a> <strong>in a predictable fashion</strong>. The series of steps to follow to achieve the app-level pause and resume functionality is as follows:</p><blockquote><ol><li>Create a bound <code>Service</code> (let's call this <code>AppActiveService</code>).</li><li>In the <code>onStart()</code> of every <code>Activity</code> of your app, bind to <code>AppActiveService</code>.</li><li>In the <code>onStop()</code> of every <code>Activity</code> of your app, unbind from <code>AppActiveService</code>.</li><li>The <code>onDestroy()</code> method of <code>AppActiveService</code> represents the point when your app is "pausing"; while the <code>onBind()</code> method represents the point when your app is "resuming". Put the code you want to be run when your app "goes to the background" in <code>AppActiveService</code>'s <code>onDestroy()</code> method.</li></ol></blockquote><p>To make things even simpler, you can put all the code above in a <code>BaseActivity</code> for your application and have all your other Activities inherit from this <code>BaseActivity</code>.</p><p>If you follow the steps above, the <code>AppActiveService</code> will have at least one <code>Activity</code> bound to it as long as your app is visible to the user. When this condition is false, no <code>Activity</code> is bound to the <code>Service</code>, at which point its <code>onDestroy()</code> is called.</p><p>Do note that we are using <code>onStop()</code> and not <code>onPause()</code> to un-bind from the <code>Service</code>. If you were to use <code>onPause()</code>, then there would be zero components bound to <code>AppActiveService</code> even as you are switching from one <code>Activity</code> to the other within your own app.</p><h3>Gotchas</h3><p>One gotcha in this approach is: What happens if your app "starts another app" using an <code>Intent</code>? No <code>Activity</code> from your app will be visible to the user - thus triggering an app-pause. Whether this is acceptable or not depends on your use case.</p><h3>Conclusion</h3><p>I plan to publish the code for this procedure as a library or at least as a gist on GitHub. Before that, I'm looking for feedback on how the code can be improved and made more robust. Have you come across the need to know when your app as a whole is "going away"? How have you solved the problem?</p>