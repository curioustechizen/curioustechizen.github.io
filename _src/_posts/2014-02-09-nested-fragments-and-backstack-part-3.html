---
layout: post
title: Nested Fragments and the Backstack - Part 3
date: '2014-02-09T12:26:00.001+05:30'
author: Kiran Rao
tags:
- nested
- fragments
- programming
- backstack
- android
modified_time: '2014-02-18T17:29:46.316+05:30'
blogger_id: tag:blogger.com,1999:blog-1898571694993659507.post-4475873645553849340
blogger_orig_url: http://curioustechizen.blogspot.com/2014/02/nested-fragments-and-backstack-part-3.html
---

<p>This is the third post in the series about Nested Fragments and the Back Stack in Android. Read the previous posts here:</p> <ol><li><a href="http://curioustechizen.blogspot.com/2014/01/nested-fragments-and-back-stack.html">Part 1</a></li><li><a href="http://curioustechizen.blogspot.com/2014/02/nested-fragment-and-backstack-part-2.html">Part 2</a></li></ol> <p>The first two posts have looked at the topic taking <code>ViewPager</code> as an example. I have also mentioned repeatedly that this is not the only use case for having to maintain the back-stack of nested fragments. One use case that I threw up often in comments was about <strong>Navigation Drawers</strong>. That is exactly what this post will look into.</p> <hr><p><strong>EDIT: Some Google engineers, including the creators of the Android framework have expressed their reservations regarding this article. Read <a href="https://plus.google.com/100961288997176421259/posts/BLLi6srFtwT">this G+ thread</a> for more details. They point out that using an <code>Application</code> sub-class to save state is not a good idea, but also that saving <code>Fragment</code> instance state explicitly might in itself needs to be considered carefully. I hope to gather their thoughts and write a follow-up post in the coming weeks. Stay Tuned.</strong></p><hr> <h3 id="re-cap">Re-cap</h3> <p>Just to re-cap the conclusion from the previous article:</p> <ul><li>Consider pro-actively saving your <code>Fragment</code> states in <code>onPause</code>, particularly is the <code>Fragment</code> happens to nest other fragments inside of it. </li><li>Do not rely solely on the system saving state for you in <code>onSaveInstanceState</code>.</li><li>Use <code>FragmentManager#saveFragmentInstanceState</code> to save the Fragment state including the back-stack of nested fragment transactions for you.</li><li>Do not hold on to the saved state any longer than necessary.</li></ul> <h3 id="adapting-to-navigation-drawer">Adapting to Navigation Drawer</h3> <p>If you take the <a href="https://github.com/curioustechizen/blog-nested-fragments-backstack/tree/master/nested-fragments-backstack-part2">source code for Part 2</a> of the series, and adapt it as-is to a Navigation Drawer example, you’ll find that things don’t quite work as you’d expect. In particular, you’ll find that <em>even though you have saved the state of the <code>ContainerFragment</code> in <code>onPause</code></em>, the next time you return to this fragment, its state is cleared. </p> <p>Why is this? The alert reader might have spotted the reason.</p> <p>In the case of the <code>ViewPager</code> example, we clear the saved fragment state in <code>onDestroy()</code>. This is because of the way ViewPager works (or rather, <code>FragmentPagerAdapter</code> or <code>FragmentStatePagerAdapter</code> works): When you navigate away from a tab, the Fragment’s <code>`onPause</code> is called but none of the other life-cycle methods are called. This means <code>onDestroy</code> is skipped and the Fragment is simply torn down. <code>onDestroy</code> is only called when the hosting <code>Activity</code> is destroyed.</p> <pre style="" class="prettyprint prettyprinted"><code class="language-java"><span class="pln">    </span><span class="lit">@Override</span><span class="pln"><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> onPause</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">onPause</span><span class="pun">();</span><span class="pln"><br />        </span><span class="pun">((</span><span class="typ">NestedFragApp</span><span class="pun">)</span><span class="pln">getActivity</span><span class="pun">().</span><span class="pln">getApplication</span><span class="pun">()).</span><span class="pln">setFragmentSavedState</span><span class="pun">(</span><span class="pln">SAVED_STATE_KEY</span><span class="pun">,</span><span class="pln"> getFragmentManager</span><span class="pun">().</span><span class="pln">saveFragmentInstanceState</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">));</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /><br />    </span><span class="lit">@Override</span><span class="pln"><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> onDestroy</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">onDestroy</span><span class="pun">();</span><span class="pln"><br />        </span><span class="pun">((</span><span class="typ">NestedFragApp</span><span class="pun">)</span><span class="pln">getActivity</span><span class="pun">().</span><span class="pln">getApplication</span><span class="pun">()).</span><span class="pln">setFragmentSavedState</span><span class="pun">(</span><span class="pln">SAVED_STATE_KEY</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span><span class="pln"><br />    </span><span class="pun">}</span></code></pre> <p>However, when you use a Navigation Drawer, the case is different. In this situation, there is no <code>PagerAdapter</code> to deal with. When you navigate from one item in the navigation drawer to another, the “old” Fragment undergoes the complete life-cycle - <code>onPause</code> all the way to <code>onDestroy</code> and <code>onDetach</code>. As a consequence, since you’re clearing the saved Fragment state in <code>onDestroy</code> of the <code>ContainerFragment</code>, <strong>you end up clearing the state that you had just saved in <code>onPause</code></strong>.</p> <h3 id="solution">Solution?</h3> <p>Well, the solution is rather simple - just don’t clear the state in <code>onDestroy</code> of the parent Fragment! In addition, there are a few other minor changes - like the way you set the initial state of the ContainerFragment (instead of retrieving the saved state in one of the life cycle methods of the Fragment, you use <code>setInitialSavedState</code> in the static creator method). The source code for this is available at the <a href="https://github.com/curioustechizen/blog-nested-fragments-backstack">github repo</a> for this series.</p> <pre style="" class="prettyprint prettyprinted"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">ContainerFragment</span><span class="pln"> newInstance</span><span class="pun">(</span><span class="typ">SavedState</span><span class="pln"> savedState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="typ">ContainerFragment</span><span class="pln"> frag </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ContainerFragment</span><span class="pun">();</span><span class="pln"><br />        frag</span><span class="pun">.</span><span class="pln">setInitialSavedState</span><span class="pun">(</span><span class="pln">savedState</span><span class="pun">);</span><span class="pln"><br />        </span><span class="kwd">return</span><span class="pln"> frag</span><span class="pun">;</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br />    </span><span class="pun">...</span><span class="pln"><br />    </span><span class="pun">...</span><span class="pln"><br />    </span><span class="lit">@Override</span><span class="pln"><br />    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> onPause</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />        </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">onPause</span><span class="pun">();</span><span class="pln"><br />        </span><span class="pun">((</span><span class="typ">NestedFragApp</span><span class="pun">)</span><span class="pln">getActivity</span><span class="pun">().</span><span class="pln">getApplication</span><span class="pun">()).</span><span class="pln">setFragmentSavedState</span><span class="pun">(</span><span class="pln">SAVED_STATE_KEY</span><span class="pun">,</span><span class="pln"> getFragmentManager</span><span class="pun">().</span><span class="pln">saveFragmentInstanceState</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">));</span><span class="pln"><br />    </span><span class="pun">}</span></code></pre> <p>Here’s a video showing this in action (Unfortunately the Android screenrecord tool doesn’t like it if you rotate the device during the recording, but I think the video demnostrates the point sufficiently):</p> <iframe src="//www.youtube.com/embed/JEzerV4Ee_g" allowfullscreen="" height="315" width="420" frameborder="0"></iframe><div class="se-section-delimiter"></div> <h3 id="forgetting-the-saved-state">Forgetting the saved state?</h3> <p>The bullet points that we established in the previous post (re-capped at the beginning of this post) say that you should not hold on to the saved state any longer than necessary. However, we had to violate that rule in this solution because - well - it is pointless to save the state only to immediately clear it!</p> <p>However, depending on your use case you might approach this in a different manner. For example, you might only clear the fragment saved state when the hosting <code>Activity</code> is destroyed. This is <em>not</em> demonstrated in the sample code on github but should be straightforward to implement.</p>