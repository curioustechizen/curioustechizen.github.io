---
layout: post
title: Override and Debug
date: '2012-03-19T11:00:00.000+05:30'
author: Kiran Rao
tags:
- debug
- technique
- override
modified_time: '2013-01-10T12:07:54.241+05:30'
blogger_id: tag:blogger.com,1999:blog-1898571694993659507.post-2569506664082672457
blogger_orig_url: http://curioustechizen.blogspot.com/2012/03/override-and-debug.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">What would we ever do without a debugger eh? In the Java world, it’s JPDA. Integrated with your favourite IDE, it makes debugging your source code a breeze. Just set a breakpoint someplace in your code, and then step through.<br /><br />But wait. What happens when you step into code that’s outside your project? What if you step into a method that’s from a library, or from the core platform itself? You end up seeing something illegible: some bytecode, or just a “Source not found” message (if you are using Eclipse that is). Go ahead: try it out:<br /><ul><li>Write a bare minimum <code>“Hello World!”</code> application.</li><li>Put a breakpoint at the line where you print the message to <code>System.out</code>.</li><li>Now debug your application and step into the <code>System.out.println</code> method.</li></ul>What do you see?<br /><h3>&nbsp;</h3><h3>Solutions?</h3>The best solution, of course, is to attach the source code, if available. Unfortunately, most of the time the source code is not available, and even if it is, “attaching” it is not the easiest thing to do. If you have worked with Android, you know what I mean.<br /><br />What’s the second-best solution? Use the <b><i>override-debug technique</i></b>. Although this technique does have its limitations (as we will discuss later in this article), it does turn out to be useful in a large number of use-cases. The technique is as follows:<br /><ul><li>Choose the library method that you wish to debug. Note that you might not care about the method that you call directly from your code. Instead, you might be interested in a method, say, four levels deep in the call stack.</li><li>Extend the class which contains this method, and override it.</li><li>Simply call the <code>super</code> method in the overriden implementation.</li><li>Finally, while debugging, put a breakpoint in the brand new one-liner method that you just implemented.</li></ul><br />Congrats! You’ve just managed to see what’s happening four levels deep in the call hierarchy; without even having the source code.<br /><h3>&nbsp;</h3><h3>Show me some Code!:</h3>Much of that did not make sense, did it? Probably because it was all text and no code? Fear not, for the code example is here!<br /><br />I use an (admittedly contrived) example to demonstrate this technique. I have a <code>Laundry</code> class and a <code>doLaundry()</code> method within it which takes a bunch of clothes as arguments. This method<br /><ul><li>First invokes the <code>WashingMachine</code> object to wash and rinse the clothes.</li><li>Then it calls upon a <code>Dryer</code> to spin them.</li><li>Finally, it hangs out the clothes to dry on a <code>Clothesline</code>. </li></ul>All of this is within a library for which you don't have the source.The objective is to debug what is happening when the control reaches the    <code>Clothesline.hang()</code> method.<br /><br /><pre class="prettyprint"><code>public class LaundryRunner {<br />  private static Laundry laundry = new Laundry();<br /><br />  public static void main(String[] args) {<br /><br />    /*<br />     * Initialize the clothes for laundry<br />     */<br />    List clothes = new ArrayList(3);<br />    clothes.add(new ClothingItem("shirt", "white", "stained"));<br />    clothes.add(new ClothingItem("jeans", "blue", "dirty"));<br />    clothes.add(new ClothingItem("t-shirt", "red", "dirty"));<br /><br />    /*<br />     * Objective: To try to debug whats going on inside.<br />     * For example, what happens by the time the clothes reach the clothesline?<br />     */<br />    laundry.doLaundry(clothes);<br />   }<br />}</code></pre><br/>You could put a breakpoint at the <code>doLaundry()</code> invocation, but since you don't have the source attached, you draw a blank.<br /><br />The solution is to extend the <code>Clothesline</code> class as follows:<br /><br /><pre class="prettyprint"><code>public class CustomClothesline extends Clothesline {<br /><br />   @Override<br />   public void hang(List clothes) {<br />    System.out.println("Debugging in Custom Clothesline");<br />    System.out.println("Status of clothes given to me:");<br />    for(ClothingItem item: clothes){<br />     System.out.println(item.getStatus());<br />    }<br />    super.hang(clothes);<br />  }<br />}</code></pre><br/>And then, instruct the <code>Laundry</code> class to use your custom <code>Clothesline</code> instead of the default one.<br /><br /><pre class="prettyprint"><code>laundry.setLine(new CustomClothesline());<br />laundry.doLaundry(clothes);</code></pre><br/>This entire project and source code is available here. I have included the dependent project as a JAR library, but it is also available as a separate project in case you want to look at it.<br /><br />Ok that was just an example code. To see the override-debug technique in the real world, see <a href="http://code.google.com/p/android-drawable--invalidation-on-orientation-issue/">this project</a> on Google Project Hosting (pay special attention to <code>CustomDrawable.java</code> ). Here, I would ordinarily have used a <code>BitmapDrawable</code> object, but I wanted to know what happens when the <code>onBoundsChanged()</code> method is called. I achieved this by extending <code>BitmapDrawable</code> and overriding the method I was interested in.<br /><h3>&nbsp;</h3><h3>Limitations:</h3>The override debug technique has the following constraints:<br /><ul><li>The class that you want to debug must be extensible. This means it must be declared <code>public</code> and not <code>final</code>.</li><li>The method which you want to override must be, well, overridable. This means it must have a visibility of at least <code>protected</code>, and of course it should not be declared <code>final</code>.</li></ul><h3>&nbsp;</h3><h3>An aside:</h3>You’re probably thinking that the above two limitations render this technique more or less useless. After all, as a best practice, developers of libraries and frameworks are unlikely to allow overriding of their classes and methods unless they are explicitly designed to do so (for example life-cycle methods).<br /><br />It turns out in practice this is not much of a constraint. Frameworks like Android allow you to extend and override almost anything. The following is a stackoverflow discussion on this topic.<br /><div class="onlyShowAcceptedAnswer-true" id="stacktack-8091624"></div></div><script>prettyPrint()</script>