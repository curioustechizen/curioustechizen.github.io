---
layout: post
title: 'Android Constants: Preference Keys, Actions, Extras and more'
date: '2013-02-18T13:30:00.000+05:30'
author: Kiran Rao
tags:
- technique
- programming
- constants
- android
modified_time: '2013-02-18T13:30:11.978+05:30'
blogger_id: tag:blogger.com,1999:blog-1898571694993659507.post-3491371269212048886
blogger_orig_url: http://curioustechizen.blogspot.com/2013/02/android-constants-preference-keys.html
---

<p>The content of this post may seem ... well .. trivial at first, but I have tripped over these so many times that I decided to write it up - at least to keep me reminded of it, if not for any other reason!</p><p>If you have written anything more than a HelloWorld app in Android, chances are you have had to work with a plethora of program elements that are represented as <code>String</code>s. Consider this sampling:</p><ul><li>Keys for <code>SharedPreferences</code> are <code>String</code>s</li><li>Keys for <code>Bundle</code>s are <code>String</code>s</li><li><code>Intent</code> extras are <code>Bundle</code>s, and hence, if you want to include any extras or retrieve them from <code>Intent</code>s, you use their <code>String</code> keys to work with them. Ditto with <code>Fragment</code> arguments</li><li><code>Intent</code> and <code>IntentFilter</code> actions (and categories) are <code>String</code>s themselves</li><li>. . .</li></ul><p>I used to deal with these the lazy way: Declare the keys as <code>public static</code> where they are first used (or where they "belong" logically) and refer to them from wherever they are needed in the code. Examples of the class that is the logical owner might be:</p><ul><li>The class that broadcasts an <code>Intent</code></li><li>The class that creates or sends a non-broadcast <code>Intent</code> (this might be an <code>Activity</code> or <code>Service</code> for example)</li><li>The class that creates a <code>SharedPreference</code> for editing</li></ul><p>However, I quickly found out that often it is not possible to cleanly define these keys as belonging to a particular class. Further, since you might end up with a handful of extras, qualifying the class name becomes tedious - more so since it is likely that Activities or Services can have quite long names. How readable is this snippet?</p><p><a id="basic-example"></a></p><pre class="prettyprint"><code>if(AbstractBaseLiveModeActivity.ACTION_LIVE_UPDATE.equals(intent.getAction())){<br />    Bundle extras = intent.getExtras();<br />    if(extras.containsKey(AbstractBaseLiveModeActivity.EXTRA_LIVE_UPDATE_TIMESTAMP)){<br />        long timestamp = extras.getLong(AbstractBaseLiveModeActivity.EXTRA_LIVE_UPDATE_TIMESTAMP);<br />        // Do something with timestamp here<br />    }<br />}<br /></code></pre><h3>Constants Almighty</h3><p>One common solution to this problem is to put everything into one "God" object called <code>Constants</code> or whatever, and prefix the constant names with <code>EXTRA_</code>, <code>ACTION_</code> or other such descriptive characters to keep them distinct.</p><pre class="prettyprint"><code>public class Constants{<br />    private Constants(){}<br /><br />    public static final String ACTION_LIVE_UPDATE = "com.myawesomeapp.action.LIVE_UPDATE";<br />    // ...<br /><br />    public static final String EXTRA_LIVE_UPDATE_TIMESTAMP = "com.myawesomeapp.extra.LIVE_UPDATE_TIMESTAMP";<br />    // ...<br /><br />}<br /></code></pre><p>Now, we've solved the readability problem since we just qualify the constant names with <code>Constant.</code> So, all's well, right?</p><p><a id="disadvantages"></a><strong>Wrong!</strong></p><p>The problem with this approach is as the number of extras, actions and preference keys increases, the <code>Constants</code> class quickly becomes unmanageable. Also, having to use the <code>ACTION_</code> and <code>EXTRA_</code> prefixes hinders usability with some IDE's. For example, with Eclipse, even if you know that you want <code>EXTRA_LIVE_UPDATE_TIMESTAMP</code>, you are forced to type the first six characters without which the code assist will not be able to filter only the extras.</p><p>Try using Eclipse to find a particular action or extra from the <code>Intent</code> class if you want to see a real-world example of what I mean.<br></p><p><a id="split-constant-files"></a></p><h3>Split it up into distinct constant files</h3><p>Here's what I do to keep my code free of such stutter. I simply split up the "God" <code>Constants</code> class into several smaller, easier-to-manage constants classes. Like so:</p><pre class="prettyprint"><code>public class Extras{<br />    private Extras(){}<br /><br />    private static String createExtra(String suffix){<br />        return Constants.NAMESPACE_PREFIX + ".extra."+suffix; //NAMESPACE_PREFIX could be "com.myawesomeapp"<br />    }<br /><br />    public static final String LIVE_UPDATE_TIMESTAMP = createExtra("LIVE_UPDATE_TIMESTAMP");<br />    public static final String LIVE_UPDATE_VALUE = createExtra("LIVE_UPDATE_VALUE");<br />    public static final String FRIEND_ID = createExtra("FRIEND_ID");<br />    // ...<br /><br />}<br /><br />public class Broadcasts{<br />    private Broadcasts(){}<br /><br />    private static String createBroadcast(String suffix){<br />        return Constants.NAMESPACE_PREFIX + ".broadcast."+suffix; //NAMESPACE_PREFIX could be "com.myawesomeapp"<br />    }<br /><br />    public static final String LIVE_UPDATE = createBroadcast("LIVE_UPDATE");<br />    public static final String FRIEND_OFFLINE = createBroadcast("FRIEND_OFFLINE");<br />    // ...<br />}<br /><br />public class Actions{<br />    private Actions(){}<br /><br />    private static String createAction(String suffix){<br />        return Constants.NAMESPACE_PREFIX + ".action."+suffix; //NAMESPACE_PREFIX could be "com.myawesomeapp"<br />    }<br /><br />    public static final String JOIN_CHAT = createAction("JOIN_CHAT");<br />    // ...<br />}<br /></code></pre><p>You could create classes for Categories, Preference Keys and so on. Note that I differentiate between Broadcasts and Actions because although they are both Intents, they are logically very different. Now, <a href="#basic-example">this code snippet</a> changes to:</p><pre class="prettyprint"><code>if(Broadcasts.LIVE_UPDATE.equals(intent.getAction())){<br />    Bundle extras = intent.getExtras();<br />    if(extras.containsKey(Extras.LIVE_UPDATE_TIMESTAMP)){<br />        long timestamp = extras.getLong(Extras.LIVE_UPDATE_TIMESTAMP);<br />        // Do something with timestamp here<br />    }<br />}<br /></code></pre><p>Which code snippet would your rather see, especially six months from now when you have to fix a bug? Also note that we've made it far more easy to find the exact action or extra that we want using our IDEs.<br></p><h3>Wait, what about constants in XMLs?</h3><p>Glad you asked. In android, many of these constants are used not only in Java code, but also from XML files.</p><ul><li>Preference keys can be referenced in <a href="http://developer.android.com/guide/topics/ui/settings.html#DefiningPrefs">preferences XML</a> files via the <code>&lt;PreferenceScreen&gt;</code> element.</li><li>Intents can be declared in <code>AndroidManifest.xml</code>. This means, the <code>Intent</code> action and categories can be referenced from the manifest.</li><li><code>BroadcastReceiver</code>s can be declared in <code>AndroidManifest.xml</code>. The <code>&lt;intent-filter&gt;</code> action and categories are referenced here.</li><li>. . .</li></ul><p>This presents a problem since we end up duplicating the constants here. We cannot use our <code>Broadcasts.LIVE_UPDATE</code> constant in XML, so we tend to repeat the constant value:</p><pre class="prettyprint"><code>&lt;intent-filter&gt;<br />    &lt;action android:name="com.myawesomeapp.broadcast.LIVE_UPDATE"/&gt;<br />&lt;/intent-filter&gt;<br /></code></pre><p>This is not good. Any change to any constant involves updating it at multiple places. What's more, these issues are not caught at compile time and can be hard to debug.<br></p><h3>Using String resources to avoid duplication</h3><p>One way to avoid constant literal duplication issue explained in the previous section is to use <a href="http://developer.android.com/guide/topics/resources/string-resource.html">string resources</a>. You are already using string resources for a variety of strings in your Android app. (Wait, you aren't? I strongly suggest you start doing so right now). All you need to do is add the constants as additional string resources. </p><p>To keep things clean, you could keep these constants in their own file under <code>values/</code> folder - for example <code>constants.xml</code>. In there, you could add</p><pre class="prettyprint"><code>&lt;resources&gt;<br /><br />    &lt;!-- Broadcast Actions --&gt;<br />    &lt;string name="broadcast_live_update"&gt;com.myawesomeapp.broadcast.LIVE_UPDATE&lt;/string&gt;<br />    &lt;string name="broadcast_friend_offline"&gt;com.myawesomeapp.broadcast.FRIEND_OFFLINE&lt;/string&gt;<br /><br />    &lt;!-- Intent Extras --&gt;<br />    &lt;string name="extra_live_update_timestamp"&gt;com.myawesomeapp.extra.LIVE_UPDATE_TIMESTAMP&lt;/string&gt;<br />    &lt;string name="extra_live_update_value"&gt;com.myawesomeapp.extra.LIVE_UPDATE_VALUE&lt;/string&gt;<br />    &lt;string name="extra_friend_id"&gt;com.myawesomeapp.extra.FRIEND_ID&lt;/string&gt;<br /><br />    &lt;!-- Preference Keys --&gt;<br />    &lt;string name="pref_key_update_interval"&gt;UPDATE_INTERVAL&lt;/string&gt;<br />    &lt;string name="pref_key_theme"&gt;THEME&lt;/string&gt;<br /><br />&lt;/resources&gt;<br /></code></pre><p>Then, you could access these values from XML as follows:</p><pre class="prettyprint"><code>&lt;intent-filter&gt;<br />    &lt;action android:name="@string/broadcast_live_update"/&gt;<br />&lt;/intent-filter&gt;<br /><br />&lt;Preference <br />    android:key="@string/pref_key_update_interval"<br />    ... /&gt;<br /></code></pre><p>And so on. In Java code, you'd access these as:</p><pre class="prettyprint"><code>if(getString(R.string.broadcast_live_update).equals(intent.getAction())){<br />    // ...<br />}<br /><br />mSharedPref.getLong(getString(R.string.pref_key_update_interval));<br /></code></pre><p><strong>Unfortunately, this solution has all the disadvantages I mentioned in an <a href="#disadvantages">earlier section</a></strong>. </p><p>Your <code>constants.xml</code> will quickly become a monolithic clutter. This can be addressed by creating a separate XML file for each type of constant - like <code>broadcasts.xml</code>, <code>pref_keys.xml</code> etc. Even if you do that, you will still be accessing all the resources using <code>@string/blah</code> and <code>R.string.blah</code>.</p><p>Also, IDE content assist is still a problem. Your resource names will need to be prefixed with <code>action_</code> or <code>broadcast_</code> or <code>pref_key_</code> etc and finding the key you need could be frustrating.<br></p><h3>A workable strategy</h3><p>Here's a strategy I follow to decide how I should declare these constants:</p><ul><li>For preference keys, prefer string resources. This is because you are most likely to be building your Settings screens with XML anyway.</li><li>For all other key constants, prefer <a href="#split-constant-files">split constant files</a>.</li><li>Only if you need to use these from XML, declare them as string resources.</li></ul>