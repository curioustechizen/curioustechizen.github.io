---
layout: post
title: 'Android: Passing an arbitrary object to a custom View'
date: '2013-02-01T09:34:00.000+05:30'
author: Kiran Rao
tags:
- custom-view
- android
modified_time: '2013-02-01T10:52:48.481+05:30'
blogger_id: tag:blogger.com,1999:blog-1898571694993659507.post-8560332806063756650
blogger_orig_url: http://curioustechizen.blogspot.com/2013/02/android-passing-arbitrary-object-to.html
---

<p>So, I came across a situation where I wanted to create a custom <code>View</code> in Android (let's call it <code>MyAwesomeView</code>). I had to work with a couple of constraints:</p><ol><li>I have to be able to pass in an additional object to <code>MyAwesomeView</code>.</li><li>The <code>MyAwesomeView</code> should also be usable from XML.</li><li>The <code>MyAwesomeView</code> should be distinct from the application itself - i.e., it should be possible to distribute the <code>MyAwesomeView</code> as a library.</li></ol><p>To elaborate a bit on the "pass in an additional object" part: <code>View</code> provides three standard constructors using which you can pass in </p><ul><li>a <code>Context</code>, </li><li>an <code>AttributeSet</code> and </li><li>an <code>int</code> representing the style.</li></ul><p>I want to also pass in a <a href="https://github.com/chrisbanes/Android-BitmapCache"><code>BitmapCache</code></a> object since <code>MyAwesomeView</code> uses lots of <code>Bitmap</code>s and I don't want to encounter the dreaded <code>OutOfMemoryError</code> that goes hand in hand with decoding large bitmaps in an Android app. <code>MyAwesomeView</code> decodes a bitmap only if it is not already present in the cache.</p><p>The second constraint makes things really difficult. It is possible to pass in additional "configuration" information to a <code>View</code> by <a href="http://developer.android.com/training/custom-views/create-view.html#customattr">creating custom attributes</a>.  However, this obviously cannot be used to pass in an object like a <code>BitmapCache</code>.</p><h3>Augmenting the <code>Context</code> object with additional information</h3><p>This solution I came across is as follows:</p><ul><li>Define an interface <code>BitmapCacheProvider</code> with a single method <code>provideBitmapCache()</code>;</li><li>Make your <code>Activity</code> class implement the interface defined in step 1. Override the interface method to return an appropriate <code>BitmapCache</code> object.</li><li>In the constructor of <code>MyAwesomeView</code>, check to see if the context object passed in to implements the <code>BitmapCacheProvider</code> interface. If it does - we're good. If not, then fail fast (or disable cacheing - whatever works for you).</li></ul><p>In code, here's what this would look like:</p><pre class="prettyprint"><code>/**<br /> * Interface to be implemented by the Context (Activity etc) in which `MyAwesomeView` runs<br /> */<br />public interface BitmapCacheProvider{<br />    BitmapCache provideBitmapCache();<br />}<br /><br />/**<br /> * An example of an Activity that implements BitmapCacheProvider<br /> */<br /><br />public class MyActivity extends Activity implements BitmapCacheProvider{<br />    //... Life-cycle methods of the Activity here<br /><br />    @Override<br />    public BitmapCache provideBitmapCache(){<br />        //Get your instance of bitmapcache here - probably from your Application<br />        BitmapCache bitmapCache = ...;<br />        return bitmapCache;<br />    }<br />}<br /><br />/**<br /> * Custom View that uses an additional object (BitmapCache) for its configuration.<br /> */<br />public class MyAwesomeView extends View{<br />    private BitmapCache mBitmapCache;<br /><br />    public MyAwesomeView(Context context){<br />        init(context, null, 0);<br />    }<br /><br />    public MyAwesomeView(Context context, AttributeSet attrs){<br />        init(context, attrs, 0);<br />    }<br /><br />    public MyAwesomeView(Context context, AttributeSet attrs, int style){<br />        init(context, attrs, style);<br />    }<br /><br />    private void init(Context context, AttributeSet attrs, int style){<br />        try{<br />            /*<br />             * Try casting the contex to BitmapCacheProvider. <br />             * <br />             * If the required interface is not implemented, <br />             * it'll throw a ClassCastException<br />             */<br />            mBitmapCache = ((BitmapCacheProvider) context).provideBitmapCache();<br />        } catch(ClassCastException e){<br />             throw new ClassCastException(context.toString()<br />                    + " must implement BitmapCacheProvider");<br />        }<br /><br />        //At this point, we have the BitmapCacheObject which we can use for further processing.<br />    }<br /><br />}<br /></code></pre><h3>Conclusion:</h3><p>What we saw in this post was how it is possible to create a custom <code>View</code> in Android, that can take in an arbitrary object in its constructor - and still be usable from XML. Admittedly, it is a bit round-about, but it has its benefits. Here are a few other points worth considering if you are following this approach:</p><ul><li>In this example, I just augmented the main <code>Activity</code> with the desired <code>interface</code>, but you might need to do this for other classes. Basically, the <code>Context</code> that is passed in to the custom <code>View</code> constructor must be enhanced to implement the interface. What this context is depends on how you are including the custom <code>View</code>.</li><li>You might argue that the BitmapCache should be part of the custom <code>View</code> and not passed in to it by the application. This depends on the use case. If you have multiple custom Views that require Bitmap cacheing (as is the case with my app), it probably makes sense for the app to maintain the cache. We might not want too maintain too many caches lest the cache overhead cancels out any benefits we derive from having the cache in the first place!</li></ul>