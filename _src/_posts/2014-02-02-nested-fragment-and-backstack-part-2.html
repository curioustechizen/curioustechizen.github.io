---
layout: post
title: Nested Fragment and the BackStack - Part 2
date: '2014-02-02T15:05:00.001+05:30'
author: Kiran Rao
tags:
- nested
- fragments
- programming
- backstack
- android
modified_time: '2014-02-18T17:29:58.627+05:30'
blogger_id: tag:blogger.com,1999:blog-1898571694993659507.post-5469762899317732254
blogger_orig_url: http://curioustechizen.blogspot.com/2014/02/nested-fragment-and-backstack-part-2.html
---

<p>This article is the second in this series about Nested Fragments and the Back Stack in Android. You can read Part 1 <a href="http://curioustechizen.blogspot.com/2014/01/nested-fragments-and-back-stack.html">here</a>. To get this post into context, take a look at the video embedded in the previous post, if nothing else.</p> <p><strong>Edit: Later posts in this series at</strong></p><ol><li><a href="http://curioustechizen.blogspot.com/2014/02/nested-fragments-and-backstack-part-3.html">Part 3</a></li></ol> <hr><p><strong>EDIT: Some Google engineers, including the creators of the Android framework have expressed their reservations regarding this article. Read <a href="https://plus.google.com/100961288997176421259/posts/BLLi6srFtwT">this G+ thread</a> for more details. They point out that using an <code>Application</code> sub-class to save state is not a good idea, but also that saving <code>Fragment</code> instance state explicitly might in itself needs to be considered carefully. I hope to gather their thoughts and write a follow-up post in the coming weeks. Stay Tuned.</strong></p><hr> <p>At the risk of sounding repetitive, I’ll start off this post by once again stating the gist of the previous post:</p> <blockquote>  <p>A Fragment’s <code>onSaveInstanceState</code> method is not guaranteed to be called when it is “removed”. The <code>Fragment</code> might simply be torn down. The only time its state might be saved is when the hosting <code>Activity</code> saves its state.</p></blockquote> <p>We also saw how this could be a problem when you use nested fragments and a <code>FragmentManager</code> doesn’t save its backstack of fragment transactions. In this part, we’ll look at one possible solution to this problem.</p><div class="se-section-delimiter"></div> <h3 id="save-state-in-onpause">Save state in onPause</h3> <p>This is the obvious solution to the problem. The Android docs also state this time and again: it is a best practice to proactively save state. Also, since <code>onPause</code> is the only callback that is guaranteed to be called, it makes sense to save your instance state here.</p> <p>Having said that, it is easy to save view states, scroll positions and even entire arbitrary objects in <code>onPause.</code> But, how does one save a back stack of fragment transactions?</p> <p>Enter <a href="http://developer.android.com/reference/android/support/v4/app/Fragment.SavedState.html"><code>Fragment.SavedState</code></a>.  You can ask the <code>FragmentManager</code> to save the state of a <code>Fragment</code> using <a href="http://developer.android.com/reference/android/support/v4/app/FragmentManager.html#saveFragmentInstanceState%28android.support.v4.app.Fragment%29"><code>saveFragmentInstanceState</code></a>. The back stack being managed by a Fragment’s nested <code>FragmentManager</code> is included in the state saved by this method.</p> <h4 id="the-application-sub-class">The <code>Application</code> sub-class</h4> <p>This post shows how you could use a sub-class of the <code>Application</code> class to save the state, but you might choose another mechanism to do so. The important thing is that the state has to be saved. We use a <code>Map</code> of strings as keys and the saved state as values in this example.</p> <pre class="prettyprint"><code>public class NestedFragApp extends Application {<br /><br />    Map&lt;String, Fragment.SavedState&gt; savedStateMap;<br /><br />    @Override<br />    public void onCreate() {<br />        savedStateMap = new HashMap&lt;String, Fragment.SavedState&gt;();<br />        super.onCreate();<br />    }<br /><br />    public void setFragmentSavedState(String key, Fragment.SavedState state){<br />        savedStateMap.put(key, state);<br />    }<br /><br />    public Fragment.SavedState getFragmentSavedState(String key){<br />        return savedStateMap.get(key);<br />    }<br /><br />}<br /></code></pre> <h4 id="explicitly-saving-fragment-state">Explicitly saving Fragment state</h4> <p>Then, you save the state of the container fragment when it pauses as follows:</p> <pre class="prettyprint"><code>@Override<br />public void onPause() {<br />    super.onPause();<br />    ((NestedFragApp) getActivity().getApplication()).setFragmentSavedState(<br />            SAVED_STATE_KEY, getFragmentManager().saveFragmentInstanceState(this));<br />}<br /></code></pre> <h4 id="initializing-the-fragment-transaction">Initializing the fragment transaction</h4> <p>Finally, remember to check whether there is a saved state for this fragment before “initializing” the fragment transaction:</p> <pre class="prettyprint"><code>SavedState fragmentSavedState = ((NestedFragApp)getActivity().getApplication())<br />        .getFragmentSavedState(SAVED_STATE_KEY);<br />if(fragmentSavedState == null){<br />    if (savedInstanceState == null) {<br />        getChildFragmentManager().beginTransaction().replace(R.id.nested_fragment_container, <br />                NestedFragmentOne.newInstance()).commit();<br />    } else {<br />        // use savedInstanceState here to restore state saved in onSaveInstance<br />    }<br />}<br /></code></pre> <p>Note that there are two “saved states” here:</p> <ol><li>The instance state saved in <code>onSaveInstanceState</code>, which is provided to you by the system via <code>savedInstanceState</code>.</li><li>The state you explicitly saved in <code>onPause</code>, which you retrieve from the <code>Application</code> object as <code>fragmentSavedState</code>.</li></ol> <p>The flow you follow for initializing the fragment is as follows:</p> <ul><li>You first check to see if you had previously explicitly saved state. If true, then you don’t need to do anything.</li><li>If not, then you proceed to check if the system had saved state for you. If true, then you use the <code>savedInstanceState</code> to restore system-saved state.</li><li>Only if neither is true, then you initiate the fragment transaction.</li></ul> <h4 id="letting-go-of-the-saved-state">Letting go of the saved state</h4> <p>One thing you need to be careful of is to not hold on to the saved fragment state any longer than necessary. For example, when the <strong>container <code>Fragment</code></strong> is destroyed, you want to invalidate the back-stack associated with it as well. This sounds obvious but I overlooked it and ended up with strange behaviors.</p> <p>The best way I found was to “forget” the saved state of a container fragment in its <code>onDestroy</code>:</p> <pre class="prettyprint"><code>@Override<br />public void onDestroy() {<br />    super.onDestroy();<br />    ((NestedFragApp) getActivity().getApplication()).setFragmentSavedState(<br />            SAVED_STATE_KEY, null);<br />}<br /></code></pre> <p>With all these steps in place, the app now behaves as one would expect it to. Your position within a back-stack, even within a nested fragment, is remembered even when you navigate away and return to the top level fragment.</p> <p>Here’s a video showing how the app now behaves:</p> <iframe src="//www.youtube.com/embed/7RpzkXGJqNo" allowfullscreen="" frameborder="0" height="315" width="420"></iframe> <p>The source code for the entire series is at <a href="https://github.com/curioustechizen/blog-nested-fragments-backstack">github</a>.</p><div class="se-section-delimiter"></div> <h3 id="conclusion">Conclusion</h3> <ul><li>Consider pro-actively saving your <code>Fragment</code> states in <code>onPause</code>, particularly is the <code>Fragment</code> happens to nest other fragments inside of it. </li><li>Do not rely solely on the system saving state for you in <code>onSaveInstanceState</code>.</li><li>Use <code>FragmentManager#saveFragmentInstanceState</code> to save the Fragment state including the back-stack of nested fragment transactions for you.</li><li>Do not hold on to the saved state any longer than necessary.</li></ul> <p>This article looked at ActionBar tabs with a ViewPager, but this concept applies to other situations where one would use nested Fragments (Navigation Drawers for example).</p>