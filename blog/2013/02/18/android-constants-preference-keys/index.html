<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en" class="no-js" prefix="og: http://ogp.me/ns#"> <!--<![endif]-->
  <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <meta http-equiv="content-language" content="en" />
      <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

      
        <meta name="description" content="A place for discussing anything tech. Old and new. Experiences and Opinions. Questions and rants. Primarily programming-related, but not exclusively.">

      

      <title> Android Constants: Preference Keys, Actions, Extras and more | Curious Techizen</title>
      
<link href='http://fonts.googleapis.com/css?family=Roboto:400,700,300,700italic|Source+Code+Pro:400,700' rel='stylesheet' type='text/css'>
<link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
      <link rel="stylesheet" type="text/css" href="/blog/css/main.css" />
      <link href="http://localhost:4000/blog/feed.xml" type="application/rss+xml" rel="alternate" title="RSS2.0">
      <link rel="shortcut icon" href="/blog/favicon.ico">

      
        


      

      <!-- Begin Jekyll SEO tag v2.1.0 -->
<title>Android Constants: Preference Keys, Actions, Extras and more - Curious Techizen</title>
<meta property="og:title" content="Android Constants: Preference Keys, Actions, Extras and more" />
<meta name="description" content="The content of this post may seem ... well .. trivial at first, but I have tripped over these so many times that I decided to write it up - at least to keep me reminded of it, if not for any other reason! If you have written anything more than a HelloWorld app in Android, chances are you have had to work with a plethora of program elements that are represented as Strings. Consider this sampling: Keys for SharedPreferences are StringsKeys for Bundles are StringsIntent extras are Bundles, and hence, if you want to include any extras or retrieve them from Intents, you use their String keys to work with them. Ditto with Fragment argumentsIntent and IntentFilter actions (and categories) are Strings themselves. . . I used to deal with these the lazy way: Declare the keys as public static where they are first used (or where they &quot;belong&quot; logically) and refer to them from wherever they are needed in the code. Examples of the class that is the logical owner might be: The class that broadcasts an IntentThe class that creates or sends a non-broadcast Intent (this might be an Activity or Service for example)The class that creates a SharedPreference for editing However, I quickly found out that often it is not possible to cleanly define these keys as belonging to a particular class. Further, since you might end up with a handful of extras, qualifying the class name becomes tedious - more so since it is likely that Activities or Services can have quite long names. How readable is this snippet? if(AbstractBaseLiveModeActivity.ACTION_LIVE_UPDATE.equals(intent.getAction())){ Bundle extras = intent.getExtras(); if(extras.containsKey(AbstractBaseLiveModeActivity.EXTRA_LIVE_UPDATE_TIMESTAMP)){ long timestamp = extras.getLong(AbstractBaseLiveModeActivity.EXTRA_LIVE_UPDATE_TIMESTAMP); // Do something with timestamp here }} Constants Almighty One common solution to this problem is to put everything into one &quot;God&quot; object called Constants or whatever, and prefix the constant names with EXTRA_, ACTION_ or other such descriptive characters to keep them distinct. public class Constants{ private Constants(){} public static final String ACTION_LIVE_UPDATE = &quot;com.myawesomeapp.action.LIVE_UPDATE&quot;; // ... public static final String EXTRA_LIVE_UPDATE_TIMESTAMP = &quot;com.myawesomeapp.extra.LIVE_UPDATE_TIMESTAMP&quot;; // ...} Now, we&#39;ve solved the readability problem since we just qualify the constant names with Constant. So, all&#39;s well, right? Wrong! The problem with this approach is as the number of extras, actions and preference keys increases, the Constants class quickly becomes unmanageable. Also, having to use the ACTION_ and EXTRA_ prefixes hinders usability with some IDE&#39;s. For example, with Eclipse, even if you know that you want EXTRA_LIVE_UPDATE_TIMESTAMP, you are forced to type the first six characters without which the code assist will not be able to filter only the extras. Try using Eclipse to find a particular action or extra from the Intent class if you want to see a real-world example of what I mean. Split it up into distinct constant files Here&#39;s what I do to keep my code free of such stutter. I simply split up the &quot;God&quot; Constants class into several smaller, easier-to-manage constants classes. Like so: public class Extras{ private Extras(){} private static String createExtra(String suffix){ return Constants.NAMESPACE_PREFIX + &quot;.extra.&quot;+suffix; //NAMESPACE_PREFIX could be &quot;com.myawesomeapp&quot; } public static final String LIVE_UPDATE_TIMESTAMP = createExtra(&quot;LIVE_UPDATE_TIMESTAMP&quot;); public static final String LIVE_UPDATE_VALUE = createExtra(&quot;LIVE_UPDATE_VALUE&quot;); public static final String FRIEND_ID = createExtra(&quot;FRIEND_ID&quot;); // ...}public class Broadcasts{ private Broadcasts(){} private static String createBroadcast(String suffix){ return Constants.NAMESPACE_PREFIX + &quot;.broadcast.&quot;+suffix; //NAMESPACE_PREFIX could be &quot;com.myawesomeapp&quot; } public static final String LIVE_UPDATE = createBroadcast(&quot;LIVE_UPDATE&quot;); public static final String FRIEND_OFFLINE = createBroadcast(&quot;FRIEND_OFFLINE&quot;); // ...}public class Actions{ private Actions(){} private static String createAction(String suffix){ return Constants.NAMESPACE_PREFIX + &quot;.action.&quot;+suffix; //NAMESPACE_PREFIX could be &quot;com.myawesomeapp&quot; } public static final String JOIN_CHAT = createAction(&quot;JOIN_CHAT&quot;); // ...} You could create classes for Categories, Preference Keys and so on. Note that I differentiate between Broadcasts and Actions because although they are both Intents, they are logically very different. Now, this code snippet changes to: if(Broadcasts.LIVE_UPDATE.equals(intent.getAction())){ Bundle extras = intent.getExtras(); if(extras.containsKey(Extras.LIVE_UPDATE_TIMESTAMP)){ long timestamp = extras.getLong(Extras.LIVE_UPDATE_TIMESTAMP); // Do something with timestamp here }} Which code snippet would your rather see, especially six months from now when you have to fix a bug? Also note that we&#39;ve made it far more easy to find the exact action or extra that we want using our IDEs. Wait, what about constants in XMLs? Glad you asked. In android, many of these constants are used not only in Java code, but also from XML files. Preference keys can be referenced in preferences XML files via the &lt;PreferenceScreen&gt; element.Intents can be declared in AndroidManifest.xml. This means, the Intent action and categories can be referenced from the manifest.BroadcastReceivers can be declared in AndroidManifest.xml. The &lt;intent-filter&gt; action and categories are referenced here.. . . This presents a problem since we end up duplicating the constants here. We cannot use our Broadcasts.LIVE_UPDATE constant in XML, so we tend to repeat the constant value: &lt;intent-filter&gt; &lt;action android:name=&quot;com.myawesomeapp.broadcast.LIVE_UPDATE&quot;/&gt;&lt;/intent-filter&gt; This is not good. Any change to any constant involves updating it at multiple places. What&#39;s more, these issues are not caught at compile time and can be hard to debug. Using String resources to avoid duplication One way to avoid constant literal duplication issue explained in the previous section is to use string resources. You are already using string resources for a variety of strings in your Android app. (Wait, you aren&#39;t? I strongly suggest you start doing so right now). All you need to do is add the constants as additional string resources. To keep things clean, you could keep these constants in their own file under values/ folder - for example constants.xml. In there, you could add &lt;resources&gt; &lt;!-- Broadcast Actions --&gt; &lt;string name=&quot;broadcast_live_update&quot;&gt;com.myawesomeapp.broadcast.LIVE_UPDATE&lt;/string&gt; &lt;string name=&quot;broadcast_friend_offline&quot;&gt;com.myawesomeapp.broadcast.FRIEND_OFFLINE&lt;/string&gt; &lt;!-- Intent Extras --&gt; &lt;string name=&quot;extra_live_update_timestamp&quot;&gt;com.myawesomeapp.extra.LIVE_UPDATE_TIMESTAMP&lt;/string&gt; &lt;string name=&quot;extra_live_update_value&quot;&gt;com.myawesomeapp.extra.LIVE_UPDATE_VALUE&lt;/string&gt; &lt;string name=&quot;extra_friend_id&quot;&gt;com.myawesomeapp.extra.FRIEND_ID&lt;/string&gt; &lt;!-- Preference Keys --&gt; &lt;string name=&quot;pref_key_update_interval&quot;&gt;UPDATE_INTERVAL&lt;/string&gt; &lt;string name=&quot;pref_key_theme&quot;&gt;THEME&lt;/string&gt;&lt;/resources&gt; Then, you could access these values from XML as follows: &lt;intent-filter&gt; &lt;action android:name=&quot;@string/broadcast_live_update&quot;/&gt;&lt;/intent-filter&gt;&lt;Preference android:key=&quot;@string/pref_key_update_interval&quot; ... /&gt; And so on. In Java code, you&#39;d access these as: if(getString(R.string.broadcast_live_update).equals(intent.getAction())){ // ...}mSharedPref.getLong(getString(R.string.pref_key_update_interval)); Unfortunately, this solution has all the disadvantages I mentioned in an earlier section. Your constants.xml will quickly become a monolithic clutter. This can be addressed by creating a separate XML file for each type of constant - like broadcasts.xml, pref_keys.xml etc. Even if you do that, you will still be accessing all the resources using @string/blah and R.string.blah. Also, IDE content assist is still a problem. Your resource names will need to be prefixed with action_ or broadcast_ or pref_key_ etc and finding the key you need could be frustrating. A workable strategy Here&#39;s a strategy I follow to decide how I should declare these constants: For preference keys, prefer string resources. This is because you are most likely to be building your Settings screens with XML anyway.For all other key constants, prefer split constant files.Only if you need to use these from XML, declare them as string resources." />
<meta property="og:description" content="The content of this post may seem ... well .. trivial at first, but I have tripped over these so many times that I decided to write it up - at least to keep me reminded of it, if not for any other reason! If you have written anything more than a HelloWorld app in Android, chances are you have had to work with a plethora of program elements that are represented as Strings. Consider this sampling: Keys for SharedPreferences are StringsKeys for Bundles are StringsIntent extras are Bundles, and hence, if you want to include any extras or retrieve them from Intents, you use their String keys to work with them. Ditto with Fragment argumentsIntent and IntentFilter actions (and categories) are Strings themselves. . . I used to deal with these the lazy way: Declare the keys as public static where they are first used (or where they &quot;belong&quot; logically) and refer to them from wherever they are needed in the code. Examples of the class that is the logical owner might be: The class that broadcasts an IntentThe class that creates or sends a non-broadcast Intent (this might be an Activity or Service for example)The class that creates a SharedPreference for editing However, I quickly found out that often it is not possible to cleanly define these keys as belonging to a particular class. Further, since you might end up with a handful of extras, qualifying the class name becomes tedious - more so since it is likely that Activities or Services can have quite long names. How readable is this snippet? if(AbstractBaseLiveModeActivity.ACTION_LIVE_UPDATE.equals(intent.getAction())){ Bundle extras = intent.getExtras(); if(extras.containsKey(AbstractBaseLiveModeActivity.EXTRA_LIVE_UPDATE_TIMESTAMP)){ long timestamp = extras.getLong(AbstractBaseLiveModeActivity.EXTRA_LIVE_UPDATE_TIMESTAMP); // Do something with timestamp here }} Constants Almighty One common solution to this problem is to put everything into one &quot;God&quot; object called Constants or whatever, and prefix the constant names with EXTRA_, ACTION_ or other such descriptive characters to keep them distinct. public class Constants{ private Constants(){} public static final String ACTION_LIVE_UPDATE = &quot;com.myawesomeapp.action.LIVE_UPDATE&quot;; // ... public static final String EXTRA_LIVE_UPDATE_TIMESTAMP = &quot;com.myawesomeapp.extra.LIVE_UPDATE_TIMESTAMP&quot;; // ...} Now, we&#39;ve solved the readability problem since we just qualify the constant names with Constant. So, all&#39;s well, right? Wrong! The problem with this approach is as the number of extras, actions and preference keys increases, the Constants class quickly becomes unmanageable. Also, having to use the ACTION_ and EXTRA_ prefixes hinders usability with some IDE&#39;s. For example, with Eclipse, even if you know that you want EXTRA_LIVE_UPDATE_TIMESTAMP, you are forced to type the first six characters without which the code assist will not be able to filter only the extras. Try using Eclipse to find a particular action or extra from the Intent class if you want to see a real-world example of what I mean. Split it up into distinct constant files Here&#39;s what I do to keep my code free of such stutter. I simply split up the &quot;God&quot; Constants class into several smaller, easier-to-manage constants classes. Like so: public class Extras{ private Extras(){} private static String createExtra(String suffix){ return Constants.NAMESPACE_PREFIX + &quot;.extra.&quot;+suffix; //NAMESPACE_PREFIX could be &quot;com.myawesomeapp&quot; } public static final String LIVE_UPDATE_TIMESTAMP = createExtra(&quot;LIVE_UPDATE_TIMESTAMP&quot;); public static final String LIVE_UPDATE_VALUE = createExtra(&quot;LIVE_UPDATE_VALUE&quot;); public static final String FRIEND_ID = createExtra(&quot;FRIEND_ID&quot;); // ...}public class Broadcasts{ private Broadcasts(){} private static String createBroadcast(String suffix){ return Constants.NAMESPACE_PREFIX + &quot;.broadcast.&quot;+suffix; //NAMESPACE_PREFIX could be &quot;com.myawesomeapp&quot; } public static final String LIVE_UPDATE = createBroadcast(&quot;LIVE_UPDATE&quot;); public static final String FRIEND_OFFLINE = createBroadcast(&quot;FRIEND_OFFLINE&quot;); // ...}public class Actions{ private Actions(){} private static String createAction(String suffix){ return Constants.NAMESPACE_PREFIX + &quot;.action.&quot;+suffix; //NAMESPACE_PREFIX could be &quot;com.myawesomeapp&quot; } public static final String JOIN_CHAT = createAction(&quot;JOIN_CHAT&quot;); // ...} You could create classes for Categories, Preference Keys and so on. Note that I differentiate between Broadcasts and Actions because although they are both Intents, they are logically very different. Now, this code snippet changes to: if(Broadcasts.LIVE_UPDATE.equals(intent.getAction())){ Bundle extras = intent.getExtras(); if(extras.containsKey(Extras.LIVE_UPDATE_TIMESTAMP)){ long timestamp = extras.getLong(Extras.LIVE_UPDATE_TIMESTAMP); // Do something with timestamp here }} Which code snippet would your rather see, especially six months from now when you have to fix a bug? Also note that we&#39;ve made it far more easy to find the exact action or extra that we want using our IDEs. Wait, what about constants in XMLs? Glad you asked. In android, many of these constants are used not only in Java code, but also from XML files. Preference keys can be referenced in preferences XML files via the &lt;PreferenceScreen&gt; element.Intents can be declared in AndroidManifest.xml. This means, the Intent action and categories can be referenced from the manifest.BroadcastReceivers can be declared in AndroidManifest.xml. The &lt;intent-filter&gt; action and categories are referenced here.. . . This presents a problem since we end up duplicating the constants here. We cannot use our Broadcasts.LIVE_UPDATE constant in XML, so we tend to repeat the constant value: &lt;intent-filter&gt; &lt;action android:name=&quot;com.myawesomeapp.broadcast.LIVE_UPDATE&quot;/&gt;&lt;/intent-filter&gt; This is not good. Any change to any constant involves updating it at multiple places. What&#39;s more, these issues are not caught at compile time and can be hard to debug. Using String resources to avoid duplication One way to avoid constant literal duplication issue explained in the previous section is to use string resources. You are already using string resources for a variety of strings in your Android app. (Wait, you aren&#39;t? I strongly suggest you start doing so right now). All you need to do is add the constants as additional string resources. To keep things clean, you could keep these constants in their own file under values/ folder - for example constants.xml. In there, you could add &lt;resources&gt; &lt;!-- Broadcast Actions --&gt; &lt;string name=&quot;broadcast_live_update&quot;&gt;com.myawesomeapp.broadcast.LIVE_UPDATE&lt;/string&gt; &lt;string name=&quot;broadcast_friend_offline&quot;&gt;com.myawesomeapp.broadcast.FRIEND_OFFLINE&lt;/string&gt; &lt;!-- Intent Extras --&gt; &lt;string name=&quot;extra_live_update_timestamp&quot;&gt;com.myawesomeapp.extra.LIVE_UPDATE_TIMESTAMP&lt;/string&gt; &lt;string name=&quot;extra_live_update_value&quot;&gt;com.myawesomeapp.extra.LIVE_UPDATE_VALUE&lt;/string&gt; &lt;string name=&quot;extra_friend_id&quot;&gt;com.myawesomeapp.extra.FRIEND_ID&lt;/string&gt; &lt;!-- Preference Keys --&gt; &lt;string name=&quot;pref_key_update_interval&quot;&gt;UPDATE_INTERVAL&lt;/string&gt; &lt;string name=&quot;pref_key_theme&quot;&gt;THEME&lt;/string&gt;&lt;/resources&gt; Then, you could access these values from XML as follows: &lt;intent-filter&gt; &lt;action android:name=&quot;@string/broadcast_live_update&quot;/&gt;&lt;/intent-filter&gt;&lt;Preference android:key=&quot;@string/pref_key_update_interval&quot; ... /&gt; And so on. In Java code, you&#39;d access these as: if(getString(R.string.broadcast_live_update).equals(intent.getAction())){ // ...}mSharedPref.getLong(getString(R.string.pref_key_update_interval)); Unfortunately, this solution has all the disadvantages I mentioned in an earlier section. Your constants.xml will quickly become a monolithic clutter. This can be addressed by creating a separate XML file for each type of constant - like broadcasts.xml, pref_keys.xml etc. Even if you do that, you will still be accessing all the resources using @string/blah and R.string.blah. Also, IDE content assist is still a problem. Your resource names will need to be prefixed with action_ or broadcast_ or pref_key_ etc and finding the key you need could be frustrating. A workable strategy Here&#39;s a strategy I follow to decide how I should declare these constants: For preference keys, prefer string resources. This is because you are most likely to be building your Settings screens with XML anyway.For all other key constants, prefer split constant files.Only if you need to use these from XML, declare them as string resources." />
<link rel="canonical" href="http://localhost:4000/blog/2013/02/18/android-constants-preference-keys/" />
<meta property="og:url" content="http://localhost:4000/blog/2013/02/18/android-constants-preference-keys/" />
<meta property="og:site_name" content="Curious Techizen" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-02-18T09:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@" />
<meta name="twitter:creator" content="@Kiran Rao" />
<script type="application/ld+json">
{"@context": "http://schema.org",
"@type": "BlogPosting",
"headline": "Android Constants: Preference Keys, Actions, Extras and more",
"datePublished": "2013-02-18T09:00:00+01:00",
"description": "The content of this post may seem ... well .. trivial at first, but I have tripped over these so many times that I decided to write it up - at least to keep me reminded of it, if not for any other reason! If you have written anything more than a HelloWorld app in Android, chances are you have had to work with a plethora of program elements that are represented as Strings. Consider this sampling: Keys for SharedPreferences are StringsKeys for Bundles are StringsIntent extras are Bundles, and hence, if you want to include any extras or retrieve them from Intents, you use their String keys to work with them. Ditto with Fragment argumentsIntent and IntentFilter actions (and categories) are Strings themselves. . . I used to deal with these the lazy way: Declare the keys as public static where they are first used (or where they &quot;belong&quot; logically) and refer to them from wherever they are needed in the code. Examples of the class that is the logical owner might be: The class that broadcasts an IntentThe class that creates or sends a non-broadcast Intent (this might be an Activity or Service for example)The class that creates a SharedPreference for editing However, I quickly found out that often it is not possible to cleanly define these keys as belonging to a particular class. Further, since you might end up with a handful of extras, qualifying the class name becomes tedious - more so since it is likely that Activities or Services can have quite long names. How readable is this snippet? if(AbstractBaseLiveModeActivity.ACTION_LIVE_UPDATE.equals(intent.getAction())){ Bundle extras = intent.getExtras(); if(extras.containsKey(AbstractBaseLiveModeActivity.EXTRA_LIVE_UPDATE_TIMESTAMP)){ long timestamp = extras.getLong(AbstractBaseLiveModeActivity.EXTRA_LIVE_UPDATE_TIMESTAMP); // Do something with timestamp here }} Constants Almighty One common solution to this problem is to put everything into one &quot;God&quot; object called Constants or whatever, and prefix the constant names with EXTRA_, ACTION_ or other such descriptive characters to keep them distinct. public class Constants{ private Constants(){} public static final String ACTION_LIVE_UPDATE = &quot;com.myawesomeapp.action.LIVE_UPDATE&quot;; // ... public static final String EXTRA_LIVE_UPDATE_TIMESTAMP = &quot;com.myawesomeapp.extra.LIVE_UPDATE_TIMESTAMP&quot;; // ...} Now, we&#39;ve solved the readability problem since we just qualify the constant names with Constant. So, all&#39;s well, right? Wrong! The problem with this approach is as the number of extras, actions and preference keys increases, the Constants class quickly becomes unmanageable. Also, having to use the ACTION_ and EXTRA_ prefixes hinders usability with some IDE&#39;s. For example, with Eclipse, even if you know that you want EXTRA_LIVE_UPDATE_TIMESTAMP, you are forced to type the first six characters without which the code assist will not be able to filter only the extras. Try using Eclipse to find a particular action or extra from the Intent class if you want to see a real-world example of what I mean. Split it up into distinct constant files Here&#39;s what I do to keep my code free of such stutter. I simply split up the &quot;God&quot; Constants class into several smaller, easier-to-manage constants classes. Like so: public class Extras{ private Extras(){} private static String createExtra(String suffix){ return Constants.NAMESPACE_PREFIX + &quot;.extra.&quot;+suffix; //NAMESPACE_PREFIX could be &quot;com.myawesomeapp&quot; } public static final String LIVE_UPDATE_TIMESTAMP = createExtra(&quot;LIVE_UPDATE_TIMESTAMP&quot;); public static final String LIVE_UPDATE_VALUE = createExtra(&quot;LIVE_UPDATE_VALUE&quot;); public static final String FRIEND_ID = createExtra(&quot;FRIEND_ID&quot;); // ...}public class Broadcasts{ private Broadcasts(){} private static String createBroadcast(String suffix){ return Constants.NAMESPACE_PREFIX + &quot;.broadcast.&quot;+suffix; //NAMESPACE_PREFIX could be &quot;com.myawesomeapp&quot; } public static final String LIVE_UPDATE = createBroadcast(&quot;LIVE_UPDATE&quot;); public static final String FRIEND_OFFLINE = createBroadcast(&quot;FRIEND_OFFLINE&quot;); // ...}public class Actions{ private Actions(){} private static String createAction(String suffix){ return Constants.NAMESPACE_PREFIX + &quot;.action.&quot;+suffix; //NAMESPACE_PREFIX could be &quot;com.myawesomeapp&quot; } public static final String JOIN_CHAT = createAction(&quot;JOIN_CHAT&quot;); // ...} You could create classes for Categories, Preference Keys and so on. Note that I differentiate between Broadcasts and Actions because although they are both Intents, they are logically very different. Now, this code snippet changes to: if(Broadcasts.LIVE_UPDATE.equals(intent.getAction())){ Bundle extras = intent.getExtras(); if(extras.containsKey(Extras.LIVE_UPDATE_TIMESTAMP)){ long timestamp = extras.getLong(Extras.LIVE_UPDATE_TIMESTAMP); // Do something with timestamp here }} Which code snippet would your rather see, especially six months from now when you have to fix a bug? Also note that we&#39;ve made it far more easy to find the exact action or extra that we want using our IDEs. Wait, what about constants in XMLs? Glad you asked. In android, many of these constants are used not only in Java code, but also from XML files. Preference keys can be referenced in preferences XML files via the &lt;PreferenceScreen&gt; element.Intents can be declared in AndroidManifest.xml. This means, the Intent action and categories can be referenced from the manifest.BroadcastReceivers can be declared in AndroidManifest.xml. The &lt;intent-filter&gt; action and categories are referenced here.. . . This presents a problem since we end up duplicating the constants here. We cannot use our Broadcasts.LIVE_UPDATE constant in XML, so we tend to repeat the constant value: &lt;intent-filter&gt; &lt;action android:name=&quot;com.myawesomeapp.broadcast.LIVE_UPDATE&quot;/&gt;&lt;/intent-filter&gt; This is not good. Any change to any constant involves updating it at multiple places. What&#39;s more, these issues are not caught at compile time and can be hard to debug. Using String resources to avoid duplication One way to avoid constant literal duplication issue explained in the previous section is to use string resources. You are already using string resources for a variety of strings in your Android app. (Wait, you aren&#39;t? I strongly suggest you start doing so right now). All you need to do is add the constants as additional string resources. To keep things clean, you could keep these constants in their own file under values/ folder - for example constants.xml. In there, you could add &lt;resources&gt; &lt;!-- Broadcast Actions --&gt; &lt;string name=&quot;broadcast_live_update&quot;&gt;com.myawesomeapp.broadcast.LIVE_UPDATE&lt;/string&gt; &lt;string name=&quot;broadcast_friend_offline&quot;&gt;com.myawesomeapp.broadcast.FRIEND_OFFLINE&lt;/string&gt; &lt;!-- Intent Extras --&gt; &lt;string name=&quot;extra_live_update_timestamp&quot;&gt;com.myawesomeapp.extra.LIVE_UPDATE_TIMESTAMP&lt;/string&gt; &lt;string name=&quot;extra_live_update_value&quot;&gt;com.myawesomeapp.extra.LIVE_UPDATE_VALUE&lt;/string&gt; &lt;string name=&quot;extra_friend_id&quot;&gt;com.myawesomeapp.extra.FRIEND_ID&lt;/string&gt; &lt;!-- Preference Keys --&gt; &lt;string name=&quot;pref_key_update_interval&quot;&gt;UPDATE_INTERVAL&lt;/string&gt; &lt;string name=&quot;pref_key_theme&quot;&gt;THEME&lt;/string&gt;&lt;/resources&gt; Then, you could access these values from XML as follows: &lt;intent-filter&gt; &lt;action android:name=&quot;@string/broadcast_live_update&quot;/&gt;&lt;/intent-filter&gt;&lt;Preference android:key=&quot;@string/pref_key_update_interval&quot; ... /&gt; And so on. In Java code, you&#39;d access these as: if(getString(R.string.broadcast_live_update).equals(intent.getAction())){ // ...}mSharedPref.getLong(getString(R.string.pref_key_update_interval)); Unfortunately, this solution has all the disadvantages I mentioned in an earlier section. Your constants.xml will quickly become a monolithic clutter. This can be addressed by creating a separate XML file for each type of constant - like broadcasts.xml, pref_keys.xml etc. Even if you do that, you will still be accessing all the resources using @string/blah and R.string.blah. Also, IDE content assist is still a problem. Your resource names will need to be prefixed with action_ or broadcast_ or pref_key_ etc and finding the key you need could be frustrating. A workable strategy Here&#39;s a strategy I follow to decide how I should declare these constants: For preference keys, prefer string resources. This is because you are most likely to be building your Settings screens with XML anyway.For all other key constants, prefer split constant files.Only if you need to use these from XML, declare them as string resources.",
"url": "http://localhost:4000/blog/2013/02/18/android-constants-preference-keys/"}</script>
<!-- End Jekyll SEO tag -->


  </head>

  <body>
    <!--[if lt IE 7]>
        <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
    <![endif]-->

    <div class="off-canvas">
      <figure class="avatar">
        <img src="/blog/assets/img/avatar.jpg" alt="Picture" title="That's me, Kiran Rao.">
      </figure>
      <div class="bio">
          <h1>Hi, I'm Kiran Rao.</h1>
          <p>Android Developer. Tech enthusiast. Serial dabbler.</p>
      </div>
      <nav>
        <h6>Follow me on</h6>
        <ul>
          
          <li><a target="_blank" href="http://twitter.com/ki_run">Twitter</a></li>
          
          
          <li><a target="_blank" href="https://github.com/curioustechizen">Github</a></li>
          
          
          
          
          <li><a target="_blank" href="https://plus.google.com/116652261752707476836">Google+</a></li>
          
        </ul>
      </nav>
      <nav>
        <h6>Link</h6>
        <ul>
          <li><a href="/blog/">Home</a></li>
          <li><a href="/blog/tags/">Tags</a></li>
        </ul>
      </nav>
    </div>

    <div class="site-wrapper">

      <header>
        <div class="h-wrap">
          <h1 class="title"><a href="/blog/" title="Back to Homepage">Curious Techizen</a></h1>
          <a class="menu-icon" title="Open Bio"><span class="lines"></span></a>
        </div>
      </header>

      <main>
        <section class="single-wrap">
  <article class="single-content" itemscope itemtype="http://schema.org/BlogPosting">
    <div class="feat">
      <h5 class="page-date">
        <time datetime="2013-02-18T09:00:00+01:00" itemprop="datePublished">
          18 February 2013
        </time>
      </h5>
    </div>
    <h1 class="page-title" itemprop="name headline">Android Constants: Preference Keys, Actions, Extras and more</h1>
    <div itemprop="articleBody">
      <p>The content of this post may seem ... well .. trivial at first, but I have tripped over these so many times that I decided to write it up - at least to keep me reminded of it, if not for any other reason!</p><p>If you have written anything more than a HelloWorld app in Android, chances are you have had to work with a plethora of program elements that are represented as <code>String</code>s. Consider this sampling:</p><ul><li>Keys for <code>SharedPreferences</code> are <code>String</code>s</li><li>Keys for <code>Bundle</code>s are <code>String</code>s</li><li><code>Intent</code> extras are <code>Bundle</code>s, and hence, if you want to include any extras or retrieve them from <code>Intent</code>s, you use their <code>String</code> keys to work with them. Ditto with <code>Fragment</code> arguments</li><li><code>Intent</code> and <code>IntentFilter</code> actions (and categories) are <code>String</code>s themselves</li><li>. . .</li></ul><p>I used to deal with these the lazy way: Declare the keys as <code>public static</code> where they are first used (or where they "belong" logically) and refer to them from wherever they are needed in the code. Examples of the class that is the logical owner might be:</p><ul><li>The class that broadcasts an <code>Intent</code></li><li>The class that creates or sends a non-broadcast <code>Intent</code> (this might be an <code>Activity</code> or <code>Service</code> for example)</li><li>The class that creates a <code>SharedPreference</code> for editing</li></ul><p>However, I quickly found out that often it is not possible to cleanly define these keys as belonging to a particular class. Further, since you might end up with a handful of extras, qualifying the class name becomes tedious - more so since it is likely that Activities or Services can have quite long names. How readable is this snippet?</p><p><a id="basic-example"></a></p><pre class="prettyprint"><code>if(AbstractBaseLiveModeActivity.ACTION_LIVE_UPDATE.equals(intent.getAction())){<br />    Bundle extras = intent.getExtras();<br />    if(extras.containsKey(AbstractBaseLiveModeActivity.EXTRA_LIVE_UPDATE_TIMESTAMP)){<br />        long timestamp = extras.getLong(AbstractBaseLiveModeActivity.EXTRA_LIVE_UPDATE_TIMESTAMP);<br />        // Do something with timestamp here<br />    }<br />}<br /></code></pre><h3>Constants Almighty</h3><p>One common solution to this problem is to put everything into one "God" object called <code>Constants</code> or whatever, and prefix the constant names with <code>EXTRA_</code>, <code>ACTION_</code> or other such descriptive characters to keep them distinct.</p><pre class="prettyprint"><code>public class Constants{<br />    private Constants(){}<br /><br />    public static final String ACTION_LIVE_UPDATE = "com.myawesomeapp.action.LIVE_UPDATE";<br />    // ...<br /><br />    public static final String EXTRA_LIVE_UPDATE_TIMESTAMP = "com.myawesomeapp.extra.LIVE_UPDATE_TIMESTAMP";<br />    // ...<br /><br />}<br /></code></pre><p>Now, we've solved the readability problem since we just qualify the constant names with <code>Constant.</code> So, all's well, right?</p><p><a id="disadvantages"></a><strong>Wrong!</strong></p><p>The problem with this approach is as the number of extras, actions and preference keys increases, the <code>Constants</code> class quickly becomes unmanageable. Also, having to use the <code>ACTION_</code> and <code>EXTRA_</code> prefixes hinders usability with some IDE's. For example, with Eclipse, even if you know that you want <code>EXTRA_LIVE_UPDATE_TIMESTAMP</code>, you are forced to type the first six characters without which the code assist will not be able to filter only the extras.</p><p>Try using Eclipse to find a particular action or extra from the <code>Intent</code> class if you want to see a real-world example of what I mean.<br></p><p><a id="split-constant-files"></a></p><h3>Split it up into distinct constant files</h3><p>Here's what I do to keep my code free of such stutter. I simply split up the "God" <code>Constants</code> class into several smaller, easier-to-manage constants classes. Like so:</p><pre class="prettyprint"><code>public class Extras{<br />    private Extras(){}<br /><br />    private static String createExtra(String suffix){<br />        return Constants.NAMESPACE_PREFIX + ".extra."+suffix; //NAMESPACE_PREFIX could be "com.myawesomeapp"<br />    }<br /><br />    public static final String LIVE_UPDATE_TIMESTAMP = createExtra("LIVE_UPDATE_TIMESTAMP");<br />    public static final String LIVE_UPDATE_VALUE = createExtra("LIVE_UPDATE_VALUE");<br />    public static final String FRIEND_ID = createExtra("FRIEND_ID");<br />    // ...<br /><br />}<br /><br />public class Broadcasts{<br />    private Broadcasts(){}<br /><br />    private static String createBroadcast(String suffix){<br />        return Constants.NAMESPACE_PREFIX + ".broadcast."+suffix; //NAMESPACE_PREFIX could be "com.myawesomeapp"<br />    }<br /><br />    public static final String LIVE_UPDATE = createBroadcast("LIVE_UPDATE");<br />    public static final String FRIEND_OFFLINE = createBroadcast("FRIEND_OFFLINE");<br />    // ...<br />}<br /><br />public class Actions{<br />    private Actions(){}<br /><br />    private static String createAction(String suffix){<br />        return Constants.NAMESPACE_PREFIX + ".action."+suffix; //NAMESPACE_PREFIX could be "com.myawesomeapp"<br />    }<br /><br />    public static final String JOIN_CHAT = createAction("JOIN_CHAT");<br />    // ...<br />}<br /></code></pre><p>You could create classes for Categories, Preference Keys and so on. Note that I differentiate between Broadcasts and Actions because although they are both Intents, they are logically very different. Now, <a href="#basic-example">this code snippet</a> changes to:</p><pre class="prettyprint"><code>if(Broadcasts.LIVE_UPDATE.equals(intent.getAction())){<br />    Bundle extras = intent.getExtras();<br />    if(extras.containsKey(Extras.LIVE_UPDATE_TIMESTAMP)){<br />        long timestamp = extras.getLong(Extras.LIVE_UPDATE_TIMESTAMP);<br />        // Do something with timestamp here<br />    }<br />}<br /></code></pre><p>Which code snippet would your rather see, especially six months from now when you have to fix a bug? Also note that we've made it far more easy to find the exact action or extra that we want using our IDEs.<br></p><h3>Wait, what about constants in XMLs?</h3><p>Glad you asked. In android, many of these constants are used not only in Java code, but also from XML files.</p><ul><li>Preference keys can be referenced in <a href="http://developer.android.com/guide/topics/ui/settings.html#DefiningPrefs">preferences XML</a> files via the <code>&lt;PreferenceScreen&gt;</code> element.</li><li>Intents can be declared in <code>AndroidManifest.xml</code>. This means, the <code>Intent</code> action and categories can be referenced from the manifest.</li><li><code>BroadcastReceiver</code>s can be declared in <code>AndroidManifest.xml</code>. The <code>&lt;intent-filter&gt;</code> action and categories are referenced here.</li><li>. . .</li></ul><p>This presents a problem since we end up duplicating the constants here. We cannot use our <code>Broadcasts.LIVE_UPDATE</code> constant in XML, so we tend to repeat the constant value:</p><pre class="prettyprint"><code>&lt;intent-filter&gt;<br />    &lt;action android:name="com.myawesomeapp.broadcast.LIVE_UPDATE"/&gt;<br />&lt;/intent-filter&gt;<br /></code></pre><p>This is not good. Any change to any constant involves updating it at multiple places. What's more, these issues are not caught at compile time and can be hard to debug.<br></p><h3>Using String resources to avoid duplication</h3><p>One way to avoid constant literal duplication issue explained in the previous section is to use <a href="http://developer.android.com/guide/topics/resources/string-resource.html">string resources</a>. You are already using string resources for a variety of strings in your Android app. (Wait, you aren't? I strongly suggest you start doing so right now). All you need to do is add the constants as additional string resources. </p><p>To keep things clean, you could keep these constants in their own file under <code>values/</code> folder - for example <code>constants.xml</code>. In there, you could add</p><pre class="prettyprint"><code>&lt;resources&gt;<br /><br />    &lt;!-- Broadcast Actions --&gt;<br />    &lt;string name="broadcast_live_update"&gt;com.myawesomeapp.broadcast.LIVE_UPDATE&lt;/string&gt;<br />    &lt;string name="broadcast_friend_offline"&gt;com.myawesomeapp.broadcast.FRIEND_OFFLINE&lt;/string&gt;<br /><br />    &lt;!-- Intent Extras --&gt;<br />    &lt;string name="extra_live_update_timestamp"&gt;com.myawesomeapp.extra.LIVE_UPDATE_TIMESTAMP&lt;/string&gt;<br />    &lt;string name="extra_live_update_value"&gt;com.myawesomeapp.extra.LIVE_UPDATE_VALUE&lt;/string&gt;<br />    &lt;string name="extra_friend_id"&gt;com.myawesomeapp.extra.FRIEND_ID&lt;/string&gt;<br /><br />    &lt;!-- Preference Keys --&gt;<br />    &lt;string name="pref_key_update_interval"&gt;UPDATE_INTERVAL&lt;/string&gt;<br />    &lt;string name="pref_key_theme"&gt;THEME&lt;/string&gt;<br /><br />&lt;/resources&gt;<br /></code></pre><p>Then, you could access these values from XML as follows:</p><pre class="prettyprint"><code>&lt;intent-filter&gt;<br />    &lt;action android:name="@string/broadcast_live_update"/&gt;<br />&lt;/intent-filter&gt;<br /><br />&lt;Preference <br />    android:key="@string/pref_key_update_interval"<br />    ... /&gt;<br /></code></pre><p>And so on. In Java code, you'd access these as:</p><pre class="prettyprint"><code>if(getString(R.string.broadcast_live_update).equals(intent.getAction())){<br />    // ...<br />}<br /><br />mSharedPref.getLong(getString(R.string.pref_key_update_interval));<br /></code></pre><p><strong>Unfortunately, this solution has all the disadvantages I mentioned in an <a href="#disadvantages">earlier section</a></strong>. </p><p>Your <code>constants.xml</code> will quickly become a monolithic clutter. This can be addressed by creating a separate XML file for each type of constant - like <code>broadcasts.xml</code>, <code>pref_keys.xml</code> etc. Even if you do that, you will still be accessing all the resources using <code>@string/blah</code> and <code>R.string.blah</code>.</p><p>Also, IDE content assist is still a problem. Your resource names will need to be prefixed with <code>action_</code> or <code>broadcast_</code> or <code>pref_key_</code> etc and finding the key you need could be frustrating.<br></p><h3>A workable strategy</h3><p>Here's a strategy I follow to decide how I should declare these constants:</p><ul><li>For preference keys, prefer string resources. This is because you are most likely to be building your Settings screens with XML anyway.</li><li>For all other key constants, prefer <a href="#split-constant-files">split constant files</a>.</li><li>Only if you need to use these from XML, declare them as string resources.</li></ul>
    </div>
    
    <div class="page-tags">
      <ul>
        
        <li>
          
          <a href="javascript:void(0);" class="disabled">technique</a>
          
        </li>
        
        <li>
          
          <a href="javascript:void(0);" class="disabled">programming</a>
          
        </li>
        
        <li>
          
          <a href="javascript:void(0);" class="disabled">constants</a>
          
        </li>
        
        <li>
          
          <a href="/blog/tags/android">Android</a>
          
        </li>
        
      </ul>
    </div>
    
    <h6 class="back-to-top"><a href="#top">Back to Top</a></h6>
    
      <a rel="next" href="/blog/2013/03/09/shift-to-octopress-postponed/" id="next">
        <span class="nav-title nav-title-next">newer</span> &rarr;
      </a>
    
    
      <a rel="prev" href="/blog/2013/02/01/android-passing-arbitrary-object-to/" id="prev">
        &larr; <span class="nav-title nav-title-prev">older</span>
      </a>
    
  </article>
  
</section>

      </main>

      <footer>
        <small>Powered by Jekyll - Theme: <a href="https://github.com/ogaclejapan/materi-for-jekyll">materi</a> - &copy; ogaclejapan</small>
      </footer>

    </div>
    

    <script src="/blog/js/main.js"></script>
    
    
      <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-66125769-1', 'kiranrao.in');
        ga('send', 'pageview');
      </script>
    

  </body>
</html>
